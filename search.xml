<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[netty]]></title>
    <url>%2F2017%2F12%2F31%2Fnetty%2F</url>
    <content type="text"><![CDATA[Netty学习netty启动与JavaNio启动比对​ 这是一个netty启动和JavaNio启动一个Socket服务的简单对比，不包含详细的分析，提供自己对Netty的简单的分析。 开启一个服务套接字ServerSocketChannel在Netty中主要使用的类：NioServerSocketChannel JavaNio开启一个服务套接字通道SocketChannel1ServerSocketChannel ssc = ServerSocketChannel.open(); ​ ServerSocketChannel.open()的内部实现使用的是SelectorProvider.provider()的方法进行实现一个SelectorProvicer的单例 1ServerSocketChannel channel = SelectorProvider.provider().openServerSocketChannel() Netty开启一个服务套接字通道的方式​ 在NioServerSocketChannel中组合一个SelectorProvider，直接SelectorProvider.provider();进行初始化 NioServerSocketChannel提供一个默认的构造方法 123456789// NioServerSocketChannel实现了一个默认的SelectorProvider，这是一个单例private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider()/** * Create a new instance */public NioServerSocketChannel() &#123; this(newSocket(DEFAULT_SELECTOR_PROVIDER));&#125; 1234567891011121314private static ServerSocketChannel newSocket(SelectorProvider provider) &#123; try &#123; /** * Use the &#123;@link SelectorProvider&#125; to open &#123;@link SocketChannel&#125; and so remove condition in * &#123;@link SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise. * * See &lt;a href="https://github.com/netty/netty/issues/2308"&gt;#2308&lt;/a&gt;. */ return provider.openServerSocketChannel(); &#125; catch (IOException e) &#123; throw new ChannelException( "Failed to open a server socket.", e); &#125;&#125; ​ 当看到openServerSocketChannel()方法的时候发现Netty也是通过java nio提供的SelectorProvicer提供单例方式实现一个服务套接字的 开启一个服务套接字SelectorJavaNio开启一个服务套接字通道Selectorjava nio通过开启一个selector进行多路复用选择器 1selector = Selector.open(); 查询Selector源码发现也是一个Selector.Provider()开启一个Selector 12345678910111213141516/** * Opens a selector. * * &lt;p&gt; The new selector is created by invoking the &#123;@link * java.nio.channels.spi.SelectorProvider#openSelector openSelector&#125; method * of the system-wide default &#123;@link * java.nio.channels.spi.SelectorProvider&#125; object. &lt;/p&gt; * * @return A new selector * * @throws IOException * If an I/O error occurs */public static Selector open() throws IOException &#123; return SelectorProvider.provider().openSelector();&#125; Netty开启一个服务套接字通道的方式​ 主要使用的类：NioEventLoopGroup、MultithreadEventLoopGroup、MultithreadEventExecutorGroup、NioEventLoop，NioEventLoop$SelectorTuple，NioEventLoop#openSelector 在openSelector方法中开启一个新的Selector，其中provider是一个Selector.Provider(); 1unwrappedSelector = provider.openSelector() 在NioEventLoop中组合了一个private final SelectorProvider provider; NioEventLoop构造方法 12345NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) 在这个构造方法调用了一个openSelector方法，查看一个这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private SelectorTuple openSelector() &#123; final Selector unwrappedSelector; try &#123; unwrappedSelector = provider.openSelector(); &#125; catch (IOException e) &#123; throw new ChannelException("failed to open a new selector", e); &#125; if (DISABLE_KEYSET_OPTIMIZATION) &#123; return new SelectorTuple(unwrappedSelector); &#125; final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet(); Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; try &#123; return Class.forName( "sun.nio.ch.SelectorImpl", false, PlatformDependent.getSystemClassLoader()); &#125; catch (Throwable cause) &#123; return cause; &#125; &#125; &#125;); if (!(maybeSelectorImplClass instanceof Class) || // ensure the current selector implementation is what we can instrument. !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) &#123; if (maybeSelectorImplClass instanceof Throwable) &#123; Throwable t = (Throwable) maybeSelectorImplClass; logger.trace("failed to instrument a special java.util.Set into: &#123;&#125;", unwrappedSelector, t); &#125; return new SelectorTuple(unwrappedSelector); &#125; final Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass; Object maybeException = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; try &#123; Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys"); Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys"); Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField); if (cause != null) &#123; return cause; &#125; cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField); if (cause != null) &#123; return cause; &#125; selectedKeysField.set(unwrappedSelector, selectedKeySet); publicSelectedKeysField.set(unwrappedSelector, selectedKeySet); return null; &#125; catch (NoSuchFieldException e) &#123; return e; &#125; catch (IllegalAccessException e) &#123; return e; &#125; &#125; &#125;); if (maybeException instanceof Exception) &#123; selectedKeys = null; Exception e = (Exception) maybeException; logger.trace("failed to instrument a special java.util.Set into: &#123;&#125;", unwrappedSelector, e); return new SelectorTuple(unwrappedSelector); &#125; selectedKeys = selectedKeySet; logger.trace("instrumented a special java.util.Set into: &#123;&#125;", unwrappedSelector); return new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));&#125; ​ 这个方法中有一段代码：unwrappedSelector = provider.openSelector();这个就是在java nio中使用这provider的openSelector(); ​ 如何使用NioEventLoop类的呢，这需要了解reactor模型，这是一个基础概念的问题，在这里不进行说明，后继会加入对reactor描述，这里仅仅知道就可以了。 ​ 在实现一个ServerSocket的时候会初始化一个NioEventLoopGroup，可以是两个，一个作为reactor中的accept，一个作为io的read或者write 123456// 多线程模型,accetp作为main reactor// main reactor是一个单线程int nThreads = 1;EventLoopGroup parentGroup = new NioEventLoopGroup(nThreads);// sub reactor中一个多线程EventLoopGroup childGroup = new NioEventLoopGroup(); 看一个EventLoopGroup的类图，只画出关键的类图 ​ 在MultithreadEventExecutorGroup构造方法中调用newChild方法，实例化一个NioEventLoop并存放于children中 查看MultithreadEventExecutorGroup的构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Create a new instance. * * @param nThreads the number of threads that will be used by this instance. * @param executor the Executor to use, or &#123;@code null&#125; if the default should be used. * @param chooserFactory the &#123;@link EventExecutorChooserFactory&#125; to use. * @param args arguments which will passed to each &#123;@link #newChild(Executor, Object...)&#125; call */protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123; if (nThreads &lt;= 0) &#123; throw new IllegalArgumentException(String.format("nThreads: %d (expected: &gt; 0)", nThreads)); &#125; if (executor == null) &#123; executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); &#125; children = new EventExecutor[nThreads]; for (int i = 0; i &lt; nThreads; i ++) &#123; boolean success = false; try &#123; children[i] = newChild(executor, args); success = true; &#125; catch (Exception e) &#123; // TODO: Think about if this is a good exception type throw new IllegalStateException("failed to create a child event loop", e); &#125; finally &#123; if (!success) &#123; for (int j = 0; j &lt; i; j ++) &#123; children[j].shutdownGracefully(); &#125; for (int j = 0; j &lt; i; j ++) &#123; EventExecutor e = children[j]; try &#123; while (!e.isTerminated()) &#123; e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS); &#125; &#125; catch (InterruptedException interrupted) &#123; // Let the caller handle the interruption. Thread.currentThread().interrupt(); break; &#125; &#125; &#125; &#125; &#125; chooser = chooserFactory.newChooser(children); final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123; @Override public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123; if (terminatedChildren.incrementAndGet() == children.length) &#123; terminationFuture.setSuccess(null); &#125; &#125; &#125;; for (EventExecutor e: children) &#123; e.terminationFuture().addListener(terminationListener); &#125; Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length); Collections.addAll(childrenSet, children); readonlyChildren = Collections.unmodifiableSet(childrenSet);&#125; ​ 当然这个构造方法中有很多的其它操作，但是在看源码中先关注脉络，再看细节，不要掉一个小的细节中出不来，就没有办法再看下去了；因此这段代码中我们只需要关注children[i] = newChild(executor, args);这个方法即可。 ​ 这个方法在类图中有newChild展示方法，这个方法最终实现类是NioEventLoopGroup，这里具体查看一下： 12345@Overrideprotected EventLoop newChild(Executor executor, Object... args) throws Exception &#123; return new NioEventLoop(this, executor, (SelectorProvider) args[0], ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);&#125; ​ 是的，这个方法有没有比较熟悉，对，这个就是开头讲的那个构造方法，到此时为止，完全明白了netty是如何开启一个selector的了，代码内部和java nio开启selector并没有太大的差别。 ​ 到目前为止了解了netty是如何开启一个NioServerSocketChannel的与启用一个Selector的。 将channel注册到selector中JavaNio将一个ServerSocketChannel注册到Selector中​ 将一个ServerSocketChannel注册到一个Selector，由于两个Open内部都使用了SelectorProvider.provider();这个方法是单例的，因此使用的是一个SelectorProvider 123456789101112/*** 这是第一步开启的一个ServerSocketChannel*/ServerSocketChannel ssc = ServerSocketChannel.open();/*** 这是第二步打开一个Selector*/Selector selector = Selector.open();/*** 把一个ServerSocketChannel注册到一个Selector*/ssc.register(selector, SelectionKey.OP_ACCEPT); Netty是如何注册一个ServerSocketChannel的呢？​ 需要查看实现一个ServerSocket需要的步骤： 1234567891011121314151617181920212223// Configure the server.// 多线程模型int nThreads = 1;EventLoopGroup parentGroup = new NioEventLoopGroup(nThreads);EventLoopGroup childGroup = new NioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(parentGroup, childGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new EchoServerChannelInitializer()); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync();&#125; finally &#123; // Shut down all event loops to terminate all threads. parentGroup.shutdownGracefully(); childGroup.shutdownGracefully();&#125; ​ 这就是实现一个ServerSocket的方法，查看bind方法：AbstractBootstrap—&gt;ServerBootstrap，bind为AbstractBootstrap中的一个方法，最终调用的是initAndRegister()方法，需要详细的看一下这个方法： 12345// 成员变量// ReflectiveChannelFactoryprivate volatile ChannelFactory&lt;? extends C&gt; channelFactory;在initAndRegister方法实例化了一个channel，这个channel中NioServerSocketChannel的实例channel = channelFactory.newChannel(); ​ 查看完整的initAndRegister方法 1234567891011121314151617181920212223242526272829303132333435final ChannelFuture initAndRegister() &#123; Channel channel = null; try &#123; // 成员变量实例化一个NioServerSocketChannel channel = channelFactory.newChannel(); init(channel); &#125; catch (Throwable t) &#123; if (channel != null) &#123; // channel can be null if newChannel crashed (eg SocketException("too many open files")) channel.unsafe().closeForcibly(); &#125; // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t); &#125; // group为NioEventLoopGroup，即为MultithreadEventLoopGroup ChannelFuture regFuture = config().group().register(channel); if (regFuture.cause() != null) &#123; if (channel.isRegistered()) &#123; channel.close(); &#125; else &#123; channel.unsafe().closeForcibly(); &#125; &#125; // If we are here and the promise is not failed, it's one of the following cases: // 1) If we attempted registration from the event loop, the registration has been completed at this point. // i.e. It's safe to attempt bind() or connect() now because the channel has been registered. // 2) If we attempted registration from the other thread, the registration request has been successfully // added to the event loop's task queue for later execution. // i.e. It's safe to attempt bind() or connect() now: // because bind() or connect() will be executed *after* the scheduled registration task is executed // because register(), bind(), and connect() are all bound to the same thread. return regFuture;&#125; ​ ​ 调用register方法，最终调用的是AbstractChannel的register进行channel注册到EventLoop当中。 ​ AbstractChannel中包含一个EventLoop，即一个channel只属于一个EventLoop，即把channel分配给相应的EventLoop（同时一个EventLoop只能交由一个Thread进行处理，当然这个后继会说明）。]]></content>
      <categories>
        <category>Java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
</search>
