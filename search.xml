<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[markdown diagram]]></title>
    <url>%2F2018%2F01%2F13%2Fmarkdown-diagram%2F</url>
    <content type="text"><![CDATA[[TOC] sequence这篇文章没有什么可以解释，这只是这样用的。 sequence123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 1234participant Aliceparticipant Bobparticipant JohnAlice-&gt;John: Hello John, how are you? 12345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 1234Note left of A: Note to the\n left of ANote right of A: Note to the\n right of ANote over A: Note over ANote over A,B: Note over both A and B flow12345678910st=&gt;start: 开始io=&gt;inputoutput: 输入op=&gt;operation: 操作cond=&gt;condition: 判断sub=&gt;subroutine: 子程序e=&gt;end: 结束st-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 1234567891011121314st=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End|future:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yes or No?|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|futurest-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e LaTeX行$$M=mc^2$$ 行内$M=mc^2$ mermaid:graph LR需要启用mermai才可以显示流程图 常用关键字 TB - top bottom BT - bottom top RL - right left LR - left right TD - same as TB 常用连线标识12345678910111213141516graph LRA--&gt;BAA---BBAAA--text---BBBA1-.-B1A2--text--&gt;B2A3-.text-.-B3A4-.text.-&gt;B4A5==text==&gt;B5A6==text===B6A7===B7C1[测试]C2(测试)C3&gt;测试]C4((测试))C5&#123;测试&#125; 流程选择1234graph TBA&#123;选择&#125;--&gt;|one| B1(选择B1)A&#123;选择&#125;--&gt;|two| B2(选择B2)A&#123;选择&#125;--&gt;|three| B3(选择B3) 子流程图123456789101112graph TBsubgraph onea1--&gt;a2endsubgraph twob1--&gt;b2endsubgraph threec1--&gt;c2endc1--&gt;a2 sequenceDiagram1234567891011%% Example of sequence diagram sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end 12345678participant Aliceparticipant BobAlice-&gt;John:Hello John, how are you?John-&gt;John:Fight against hypochondriaNote right of John:Rational thoughts &lt;br/&gt;prevail...John--&gt;Alice:Great!John-&gt;Bob: How about you?Bob--&gt;John: Jolly good! gantt12345678910111213gantt dateFormat YYYY-MM-DD title 这是一个甘特图section 测试一 完成任务 :done, fitst, 2018-01-01,2018-01-03 开始任务 :active, second, 2018-01-02,3d 未来任务1 :crit, three, after second, 3d 未来任务2 :crit,active, four, after three, 3dsection 测试二 完成任务 :done, fitst, 2018-01-01,2018-01-02 开始任务 :active, second, 2018-01-02,3d 未来任务1 :crit, three, after second, 3d 未来任务2 :crit,active, four, after three, 7d 用例:Customer单个标识用例标识 包含用例 包含注释 多用例标识方式]]></content>
      <categories>
        <category>markdown</category>
        <category>diagiam</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>diagiam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Channel分析]]></title>
    <url>%2F2018%2F01%2F12%2FChannel%E5%88%86%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty客户端连接分析]]></title>
    <url>%2F2018%2F01%2F09%2Fnetty%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[TOC] Netty客户端连接分析​ 不写客户端，直接通过nc命令进行连接客户端，查看Netty在服务器端是怎么处理的。 Netty服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * Echoes back any received data from a client. */public final class EchoServer &#123; static final int PORT = Integer.parseInt(System.getProperty("port", "8007")); public static void main(String[] args) throws Exception &#123; // Configure the server. // 多线程模型 int nThreads = 1; EventLoopGroup parentGroup = new NioEventLoopGroup(nThreads); EventLoopGroup childGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(parentGroup, childGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new EchoServerChannelInitializer()); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync(); &#125; finally &#123; // Shut down all event loops to terminate all threads. parentGroup.shutdownGracefully(); childGroup.shutdownGracefully(); &#125; &#125;&#125;public class EchoServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; static final boolean SSL = System.getProperty("ssl") != null; @Override public void initChannel(SocketChannel ch) throws Exception &#123; // Configure SSL. final SslContext sslCtx; if (SSL) &#123; SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); &#125; else &#123; sslCtx = null; &#125; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc())); &#125; //p.addLast(new LoggingHandler(LogLevel.INFO)); p.addLast(new EchoServerHandler()); &#125;&#125;/** * Handler implementation for the echo server. */@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ctx.write(msg); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) &#123; ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; // Close the connection when an exception is raised. cause.printStackTrace(); ctx.close(); &#125;&#125; ​ 以上是Netty官方提供的EchoServer代码，仅仅是把内部类提取出来，方便调试与查看。 NC模拟客户端连接​ 通过shell命令进行连接： 1nc 127.0.0.1 8080 Netty连接分析​ 由于之前做过Netty服务端启动分析，在这里不做描述，在之前分析中有提到在NioEventLoop#Select的，其实在netty启动与JavaNio启动比对提到JavaNio在循环等待中由ServerSocketChannel#select()进行等待，然后处理SelectionKey的Event操作，其实Netty也是一样的。 ​ 在NioEventLoop#Select调用NioEventLoop#processSelectedKeys();操作，是的，这里就是进行事件处理的代码。 Netty进行Select等待操作​ 同样的代码也是在run中提供一个死循环中进行Select的等待操作，只不过Netty进行了优化。暂时先不看优化，把整个大致的脉络理顺。 123456789101112131415161718192021222324252627282930/*** Netty进行selectedKeys的优化*/private void processSelectedKeysOptimized() &#123; for (int i = 0; i &lt; selectedKeys.size; ++i) &#123; final SelectionKey k = selectedKeys.keys[i]; // null out entry in the array to allow to have it GC'ed once the Channel close // See https://github.com/netty/netty/issues/2363 selectedKeys.keys[i] = null; final Object a = k.attachment(); if (a instanceof AbstractNioChannel) &#123; processSelectedKey(k, (AbstractNioChannel) a); &#125; else &#123; @SuppressWarnings("unchecked") NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a; processSelectedKey(k, task); &#125; if (needsToSelectAgain) &#123; // null out entries in the array to allow to have it GC'ed once the Channel close // See https://github.com/netty/netty/issues/2363 selectedKeys.reset(i + 1); selectAgain(); i = -1; &#125; &#125;&#125; ​ 那么k.attachment();是一个什么呢？我们在进行netty启动与JavaNio启动比对时候，有说明netty的channel的绑定，再回顾一下绑定的那段代码： 1selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this); ​ 可以看到这里绑定的是一个this，而这个this是什么呢？NioServerSocketChannel，是的，就是一个NioServerSocketChannel，而NioServerSocketChannel继承自AbstractNioChannel，因此调用了processSelectedKey。 ​ 而k.attachment();获取的就是一个绑定在SelectionKey的一个对象，可以是任务一个对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123; final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); if (!k.isValid()) &#123; final EventLoop eventLoop; try &#123; eventLoop = ch.eventLoop(); &#125; catch (Throwable ignored) &#123; // If the channel implementation throws an exception because there is no event loop, we ignore this // because we are only trying to determine if ch is registered to this event loop and thus has authority // to close ch. return; &#125; // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is // still healthy and should not be closed. // See https://github.com/netty/netty/issues/5125 if (eventLoop != this || eventLoop == null) &#123; return; &#125; // close the channel if the key is not valid anymore unsafe.close(unsafe.voidPromise()); return; &#125; try &#123; int readyOps = k.readyOps(); // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise // the NIO JDK channel implementation may throw a NotYetConnectedException. if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123; // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking // See https://github.com/netty/netty/issues/924 int ops = k.interestOps(); ops &amp;= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect(); &#125; // Process OP_WRITE first as we may be able to write some queued buffers and so free memory. if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write ch.unsafe().forceFlush(); &#125; // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead // to a spin loop if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123; unsafe.read(); &#125; &#125; catch (CancelledKeyException ignored) &#123; unsafe.close(unsafe.voidPromise()); &#125;&#125; ​ 其实这个方法就是一个完整的SelectionKey选择事件的处理，同样，Netty进行了优化操作。 ​ final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();获取一个NioUnSafe，正如Netty注释的一样：不会被外界调用UnSafe方法，而在netty启动绑定端口分析中有分UnSafe最终的实现类是AbstractNioMessageChannel$NioMessageUnsafe，而AbstractNioMessageChannel$NioMessageUnsafe#read(); ​ 好像Netty开始进行读取客户端的数据了，然后并不是，我们可以看一下AbstractNioMessageChannel$NioMessageUnsafe#read();的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Overridepublic void read() &#123; assert eventLoop().inEventLoop(); final ChannelConfig config = config(); final ChannelPipeline pipeline = pipeline(); final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle(); allocHandle.reset(config); boolean closed = false; Throwable exception = null; try &#123; try &#123; do &#123; int localRead = doReadMessages(readBuf); if (localRead == 0) &#123; break; &#125; if (localRead &lt; 0) &#123; closed = true; break; &#125; allocHandle.incMessagesRead(localRead); &#125; while (allocHandle.continueReading()); &#125; catch (Throwable t) &#123; exception = t; &#125; int size = readBuf.size(); for (int i = 0; i &lt; size; i ++) &#123; readPending = false; // 通过DefaultChannelPipeline进行连接处理 pipeline.fireChannelRead(readBuf.get(i)); &#125; readBuf.clear(); allocHandle.readComplete(); pipeline.fireChannelReadComplete(); if (exception != null) &#123; closed = closeOnReadError(exception); pipeline.fireExceptionCaught(exception); &#125; if (closed) &#123; inputShutdown = true; if (isOpen()) &#123; close(voidPromise()); &#125; &#125; &#125; finally &#123; // Check if there is a readPending which was not processed yet. // This could be for two reasons: // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method // // See https://github.com/netty/netty/issues/2254 if (!readPending &amp;&amp; !config.isAutoRead()) &#123; removeReadOp(); &#125; &#125;&#125; 创建NioSocketChannel123456789101112131415161718192021@Overrideprotected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123; SocketChannel ch = SocketUtils.accept(javaChannel()); try &#123; if (ch != null) &#123; buf.add(new NioSocketChannel(this, ch)); return 1; &#125; &#125; catch (Throwable t) &#123; logger.warn("Failed to create a new channel from an accepted socket.", t); try &#123; ch.close(); &#125; catch (Throwable t2) &#123; logger.warn("Failed to close a socket.", t2); &#125; &#125; return 0;&#125; ​ 这是NioServerSocketChannel#doReadMessages(buf: List);这里生成了一个SocketChannel，也是java.nio.channels.SocketChannel类，在JavaNio进行accept()的时候返回SocketChannel相同。 ​ 并把生成的NioSocketChannel放入到buf，NioSocketChannel组合了NioServerSocketChannel和SocketChannel。而NioSocketChannel中生成一个Unsafe类和一个DefaultChannelPipeline类。Unsafe生成的实例对象是NioSocketChannelUnsafe。 NioSocketChannel的类继承图 在通过DefaultChannelPipeline#fireChannelRead(msg: Object)进行fire处理。 12345678910111213141516171819202122@Overridepublic final ChannelPipeline fireChannelRead(Object msg) &#123; AbstractChannelHandlerContext.invokeChannelRead(head, msg); return this;&#125;static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123; final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next); // 获取执行的EventExecutor EventExecutor executor = next.executor(); if (executor.inEventLoop()) &#123; next.invokeChannelRead(m); &#125; else &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; next.invokeChannelRead(m); &#125; &#125;); &#125;&#125; ​ 而fire调用是从head开始的，这个在netty启动绑定端口分析详细的分析过双向链表的创建过程，这里看一下这个双向链表的表单： handler inbound outbound HeadContext false ture LoggingHandler true true ServerBootstrapAcceptor true false TailContext true false ​ 通过next.invokeChannelRead(m);进行调用下一个invokeChannelRead。 1234567891011private void invokeChannelRead(Object msg) &#123; if (invokeHandler()) &#123; try &#123; ((ChannelInboundHandler) handler()).channelRead(this, msg); &#125; catch (Throwable t) &#123; notifyHandlerException(t); &#125; &#125; else &#123; fireChannelRead(msg); &#125;&#125; ​ ==启动的时候是outbound，寻找outbount，而在开启链接的时候是inbound，寻找outbound。== ​ 而HeadContext直接调用channelRead，而在HeadContext#channelRead(this, meg); 1234@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ctx.fireChannelRead(msg);&#125; ​ 而AbstractChannelHandlerContext#fireChannelRead(msg: Object); 12345678910111213@Overridepublic ChannelHandlerContext fireChannelRead(final Object msg) &#123; invokeChannelRead(findContextInbound(), msg); return this;&#125;private AbstractChannelHandlerContext findContextInbound() &#123; AbstractChannelHandlerContext ctx = this; do &#123; ctx = ctx.next; &#125; while (!ctx.inbound); return ctx;&#125; ​ 根据上面的列表，可以看出先调用LoggingHandler-&gt;ServerBootstrapAcceptor，而在ServerBootstrapAcceptor#channelRead比较重要： 1234567891011121314151617181920212223242526@Override@SuppressWarnings("unchecked")public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; final Channel child = (Channel) msg; child.pipeline().addLast(childHandler); setChannelOptions(child, childOptions, logger); for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123; child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue()); &#125; try &#123; childGroup.register(child).addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; if (!future.isSuccess()) &#123; forceClose(child, future.cause()); &#125; &#125; &#125;); &#125; catch (Throwable t) &#123; forceClose(child, t); &#125;&#125; ​ 这个方法中重要的有一个是child.pipeline().addLast(childHandler);在这里添加了一个childHandler。把新的channel注册到eventloop上。 ​ 其实这是使用一个新的Channel，并启用新的Pipeline进行创建链表。 NioSocketChannel注册操作​ 这里注册和netty启动与JavaNio启动比对中Netty是如何注册一个ServerSocketChannel的呢的完全一样，在这里就不过多的分析了。在注册完成后即完成了客户端的连接。]]></content>
      <categories>
        <category>Java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty启动绑定端口分析]]></title>
    <url>%2F2018%2F01%2F03%2Fnetty%E5%90%AF%E5%8A%A8%E7%BB%91%E5%AE%9A%E7%AB%AF%E5%8F%A3%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[TOC] Netty胶水类​ 在开始netty分析端口绑定的时候可能会比较迷惑，因为前半部分几乎都是在分析双向链表的组装，其实我在看源码的时候也是比较迷惑，即使感到迷惑也要看下去，毕竟学习就是一个解惑的过程，看完以后也就明白了这样做的原因了。 DefaultChannelPipeline的分析​ 是的，这个方法中就一句话，即调用DefaultChannelPipeline#bind(localAddress, promise)方法，现在使用到DefaultChannelPipeline类，就需要看一下这个类，在Netty当中，这是一个胶水类： 在netty启动与JavaNio启动比对中有提到NioServerSocketChannel类的初始化，在初始化NioServerSocketChannel中会初始化AbstractChannel： 123456789101112131415161718/** * Creates a new instance. * * @param parent * the parent of this channel. &#123;@code null&#125; if there's no parent. */protected AbstractChannel(Channel parent) &#123; this.parent = parent; id = newId(); unsafe = newUnsafe(); pipeline = newChannelPipeline();&#125;/** * Returns a new &#123;@link DefaultChannelPipeline&#125; instance. */protected DefaultChannelPipeline newChannelPipeline() &#123; return new DefaultChannelPipeline(this);&#125; 既然DefaultChannelPipeline是一个胶水类，那么就需要看一下这个类的构造方法： 123456789101112131415final AbstractChannelHandlerContext head;final AbstractChannelHandlerContext tail;protected DefaultChannelPipeline(Channel channel) &#123; this.channel = ObjectUtil.checkNotNull(channel, "channel"); succeededFuture = new SucceededChannelFuture(channel, null); voidPromise = new VoidChannelPromise(channel, true); tail = new TailContext(this); head = new HeadContext(this); head.next = tail; tail.prev = head;&#125; 现在会DefaultChannelPipeline进行一个简单的描述： 在NioServerSocketChannel(在初始化任何一个Channel)时同时实例化一个DefaultChannelPipeline，Channel作为DefaultChannelPipeline的一个成员变量 初始化DefaultChannelPipeline时同时初始化一个head和tail： tail是一个ChannelInboundHandler head是一个ChannelOutboundHandler和ChannelInboundHandler tail的prev是head，head的next是tail，组成一个双向链表 ​现在只需要了解DefaultChannelPipeline的初始化即可，这里需要记得的是DefaultChannelPipeline是一个双向链表，再给一个经典的图： 这个图标识几个重点，如上述描述一致。 ServerBootstrap的分析​ 在初始化一个服务器时通过ServerBootstrap进行实例化一个引导的，现在需要回头分析这个类，其实在之前也分析过这个类，只不过是在主要关注的是两种启动的对比，分析的并不系统。 ​ 在netty启动与JavaNio启动比对中有提到AbstractBootstrap#initAndRegister()方法： 1234567891011121314151617181920212223242526272829303132333435final ChannelFuture initAndRegister() &#123; Channel channel = null; try &#123; channel = channelFactory.newChannel(); // 这个init指的是ServerBootstrapAdapter的初始化 init(channel); &#125; catch (Throwable t) &#123; if (channel != null) &#123; // channel can be null if newChannel crashed (eg SocketException("too many open files")) channel.unsafe().closeForcibly(); &#125; // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t); &#125; ChannelFuture regFuture = config().group().register(channel); if (regFuture.cause() != null) &#123; if (channel.isRegistered()) &#123; channel.close(); &#125; else &#123; channel.unsafe().closeForcibly(); &#125; &#125; // If we are here and the promise is not failed, it's one of the following cases: // 1) If we attempted registration from the event loop, the registration has been completed at this point. // i.e. It's safe to attempt bind() or connect() now because the channel has been registered. // 2) If we attempted registration from the other thread, the registration request has been successfully // added to the event loop's task queue for later execution. // i.e. It's safe to attempt bind() or connect() now: // because bind() or connect() will be executed *after* the scheduled registration task is executed // because register(), bind(), and connect() are all bound to the same thread. return regFuture;&#125; ​ 在AbstractBootstrap#initAndRegister()完成了初始化NioServerSocketChannel和Selector，并实现了select操作，由于SocketChannel和Selector并没有太大的关系，因此没有分析，遗漏的总是要补回来的，是的，这里需要回头分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridevoid init(Channel channel) throws Exception &#123; final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0(); synchronized (options) &#123; setChannelOptions(channel, options, logger); &#125; final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0(); synchronized (attrs) &#123; for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123; @SuppressWarnings("unchecked") AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey(); channel.attr(key).set(e.getValue()); &#125; &#125; ChannelPipeline p = channel.pipeline(); final EventLoopGroup currentChildGroup = childGroup; final ChannelHandler currentChildHandler = childHandler; final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions; final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs; synchronized (childOptions) &#123; currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size())); &#125; synchronized (childAttrs) &#123; currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size())); &#125; p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; @Override public void initChannel(final Channel ch) throws Exception &#123; final ChannelPipeline pipeline = ch.pipeline(); ChannelHandler handler = config.handler(); if (handler != null) &#123; pipeline.addLast(handler); &#125; ch.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; pipeline.addLast(new ServerBootstrapAcceptor( ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); &#125; &#125;); &#125; &#125;);&#125; ​ Channel和DefaultChannelPipeline是一个双向组合，因此可以通过channel获取ChannelPipeline。 ​ 这个方法中首先看一个匿名内部类：ChannelInitializer，DefaultChannelPipeline#addLast(handlers);把ChannelInitializer加入了链表，最终加入部分代码（省略部分调用）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Overridepublic final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123; final AbstractChannelHandlerContext newCtx; synchronized (this) &#123; checkMultiplicity(handler); // 把handler加入到DefaultChannelHandlerContext到 newCtx = newContext(group, filterName(name, handler), handler); addLast0(newCtx); // If the registered is false it means that the channel was not registered on an eventloop yet. // In this case we add the context to the pipeline and add a task that will call // ChannelHandler.handlerAdded(...) once the channel is registered. // 此时的registered还是false，因此ServerBootstrap$1并没有加入到链表当中 if (!registered) &#123; newCtx.setAddPending(); // 如果没有加入handler操作，由设置一个回调，等待被启用 callHandlerCallbackLater(newCtx, true); return this; &#125; EventExecutor executor = newCtx.executor(); if (!executor.inEventLoop()) &#123; newCtx.setAddPending(); executor.execute(new Runnable() &#123; @Override public void run() &#123; // 定义一个任务，并执行handler初始化操作 callHandlerAdded0(newCtx); &#125; &#125;); return this; &#125; &#125; callHandlerAdded0(newCtx); return this;&#125;private void addLast0(AbstractChannelHandlerContext newCtx) &#123; AbstractChannelHandlerContext prev = tail.prev; newCtx.prev = prev; newCtx.next = tail; prev.next = newCtx; tail.prev = newCtx;&#125;// 设置一个等待启动注册handler到链表的任务private void callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean added) &#123; assert !registered; PendingHandlerCallback task = added ? new PendingHandlerAddedTask(ctx) : new PendingHandlerRemovedTask(ctx); PendingHandlerCallback pending = pendingHandlerCallbackHead; if (pending == null) &#123; pendingHandlerCallbackHead = task; &#125; else &#123; // Find the tail of the linked-list. while (pending.next != null) &#123; pending = pending.next; &#125; pending.next = task; &#125;&#125; ​ 这段代码的意思是加入到tail之前，即先把内部类加入双向链表中，但是由于此时registered的值为false，因此此时的人仍然没有变化，链表为：head-&gt;tail。 仍然在DefaultChannelPipeline中，执行ChannelInitializer#handlerAdded 12345678910111213141516171819202122232425262728293031private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) &#123; try &#123; ctx.handler().handlerAdded(ctx); ctx.setAddComplete(); &#125; catch (Throwable t) &#123; boolean removed = false; try &#123; remove0(ctx); try &#123; ctx.handler().handlerRemoved(ctx); &#125; finally &#123; ctx.setRemoved(); &#125; removed = true; &#125; catch (Throwable t2) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Failed to remove a handler: " + ctx.name(), t2); &#125; &#125; if (removed) &#123; fireExceptionCaught(new ChannelPipelineException( ctx.handler().getClass().getName() + ".handlerAdded() has thrown an exception; removed.", t)); &#125; else &#123; fireExceptionCaught(new ChannelPipelineException( ctx.handler().getClass().getName() + ".handlerAdded() has thrown an exception; also failed to remove.", t)); &#125; &#125;&#125; 在ChannelInitializer#handlerAdded(ctx) 123456789101112131415161718192021222324252627282930/** * &#123;@inheritDoc&#125; If override this method ensure you call super! */@Overridepublic void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; if (ctx.channel().isRegistered()) &#123; // This should always be true with our current DefaultChannelPipeline implementation. // The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering // surprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers // will be added in the expected order. initChannel(ctx); &#125;&#125;@SuppressWarnings("unchecked")private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123; if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance. try &#123; initChannel((C) ctx.channel()); &#125; catch (Throwable cause) &#123; // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...). // We do so to prevent multiple calls to initChannel(...). exceptionCaught(ctx, cause); &#125; finally &#123; remove(ctx); &#125; return true; &#125; return false;&#125; ​ 开始调用ServerBootstrap$1类中的initChannel(Channel);如果在创建ServerBootstrap时没有添加handler，为了简单，假设没有添加handler，则此时的链表为：head-&gt;ServerBootstrapAcceptor-&gt;tail。此时完成了整个链表的组装，其实这时的链表也并不完成，仍然需要加工。 ​ 在回调ServerBootstrap#init(channel)方法中的匿名内部类(ChannelInitializer接口)中initChannel()的方法时继续进行链表的组装： ​ 首先添加在构造SocketServer中添加的handler，此时的链表结构：head-&gt;ServerBootstrapAcceptor-&gt;LoggingHandler-&gt;tail，再添加ServerBootstrapAcceptor，这里完成了Netty内部链表的组装：head-&gt;ServerBootstrapAcceptor-&gt;LoggingHandler-&gt;ServerBootstrapAcceptor-&gt;tail，然而并没有添加我们自己实现的Handler。 ​ 在AbstractBootstrap#initAndRegister此时完成了链表的初始化操作。正如initAndRegister的名字一样，完成channel到selector的注册及DefaultChannelPipeline的组装，接下来需要进行端口的绑定； ​ 看一下AbstractBootstrap#initAndRegister()方法的调用： 123456789101112131415161718192021222324252627282930313233343536private ChannelFuture doBind(final SocketAddress localAddress) &#123; final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; if (regFuture.isDone()) &#123; // At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise(); // 调用端口的绑定操作 doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; // Registration future is almost always fulfilled already, but just in case it's not. final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); regFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; Throwable cause = future.cause(); if (cause != null) &#123; // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an // IllegalStateException once we try to access the EventLoop of the Channel. promise.setFailure(cause); &#125; else &#123; // Registration was successful, so set the correct executor to use. // See https://github.com/netty/netty/issues/2586 promise.registered(); doBind0(regFuture, channel, localAddress, promise); &#125; &#125; &#125;); return promise; &#125;&#125; ​ 此时完成了一个双向链表的组装，下面开始接口的绑定分析。 端口绑定​ 回顾netty启动与JavaNio启动比对提到SingleThreadEventExecutor#addTask添加到Queue中，并在NioEventLoop#run启动runAllTasks启动任务，绑定端口的任务启动就是以这样的方式开始的。 ​ 在AbstractBootstrap#doBind0()方法中的代码就是绑定端口的入口，代码如下： 12345678910111213// This method is invoked before channelRegistered() is triggered. Give user handlers a chance to set up// the pipeline in its channelRegistered() implementation.channel.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; if (regFuture.isSuccess()) &#123; // bootsrtap中这个channel是NioServerSocketChannel channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); &#125; else &#123; promise.setFailure(regFuture.cause()); &#125; &#125;&#125;); 这里启动一个任务进行端口绑定操作，这篇文章主要讲这个端口绑定过程。 首先查看NioServerSocketChannel的类图NioServerSocketChannel类图如下： 由上面的代码可知channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);调用的是AbstractChannel中的bind方法： 具体的查看AbstractChannel#bind(localAddress, promise): ChannelFuture方法： 1234@Overridepublic ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123; return pipeline.bind(localAddress, promise);&#125; ​ 这个方法中就一句话，调用DefaultChannelPileline#bind(SocketAddress, ChannelPromise);这里是不是很熟悉了，就是我们上面前面分析的DefaultChannelPipeline以及AbstractChannelHandlerContext， ​ 查看一下DefaultChannelPileline#bind(SocketAddress, ChannelPromise);的方法。 1234@Overridepublic final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123; return tail.bind(localAddress, promise);&#125; ​ 看到tail，tail是一个AbstractChannelHandlerContext也很熟悉，是的，这就是链表的最后，一个节点；因此调用的也是AbstractChannelHandlerContext#bind(SocketAddress, ChannelPromise)。 ​ 这里需要分析AbstractChannelHandlerContext#bind(SocketAddress, ChannelPromise)方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) &#123; if (localAddress == null) &#123; throw new NullPointerException("localAddress"); &#125; if (isNotValidPromise(promise, false)) &#123; // cancelled return promise; &#125; // 查询findContextOutbound方法 final AbstractChannelHandlerContext next = findContextOutbound(); EventExecutor executor = next.executor(); if (executor.inEventLoop()) &#123; next.invokeBind(localAddress, promise); &#125; else &#123; safeExecute(executor, new Runnable() &#123; @Override public void run() &#123; next.invokeBind(localAddress, promise); &#125; &#125;, promise, null); &#125; return promise;&#125;private AbstractChannelHandlerContext findContextOutbound() &#123; AbstractChannelHandlerContext ctx = this; do &#123; ctx = ctx.prev; &#125; while (!ctx.outbound); return ctx;&#125;private void invokeBind(SocketAddress localAddress, ChannelPromise promise) &#123; if (invokeHandler()) &#123; try &#123; ((ChannelOutboundHandler) handler()).bind(this, localAddress, promise); &#125; catch (Throwable t) &#123; notifyOutboundHandlerException(t, promise); &#125; &#125; else &#123; bind(localAddress, promise); &#125;&#125; ​ AbstractChannelHandlerContext有两种类型，如上图描述的：ChannelInboundHandler和ChannelInboundHandler，一个是inbound和outbound；这里是查找第一个非outbound的Handler。 head-&gt;LoggingHandler-&gt;ServerBootstrapAcceptor-&gt;tail ​ ServerBootstrap$1是ChannelInitializer的一个泛化，Channelinitalizer是ChannelInboundHandlerAdapter一个泛化。因此ServerBootstrap$1是一个Inbound。 ​ Netty没有添加自定义ChannelInitializer时初始化的链表。 无自定义ChanneIinitializer初始化链表 handler inbound outbound HeadContext false ture LoggingHandler true true ServerBootstrapAcceptor true false TailContext true false ​ 现在是没有添加childHandler操作的链表，根据表可知，获取第一个ChannelInitailizer是LoggingHandler，需要看一下LoggingHandler的bind操作， 1234567@Overridepublic void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception &#123; if (logger.isEnabled(internalLevel)) &#123; logger.log(internalLevel, format(ctx, "BIND", localAddress)); &#125; ctx.bind(localAddress, promise);&#125; 可以看到仍然调用了AbstractChannelHandlerContext#bind()方法，此时的prev是HeadContext，再次调用AbstractChannelHandlerContext#invokeBind()方法，可以看到HeadContext重写了AbstractChannelHandlerContext#bind()的方法，下面是HeadContext#bind()的方法： 123456@Overridepublic void bind( ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception &#123; unsafe.bind(localAddress, promise);&#125; ​ 好像没有再调用下面的方法了，毕竟HeadContext的prev是null，而unsafe又是什么鬼呢？此时我们需要回忆一下HeadContext的实例化过程，HeadContext是DefaultChannelPipeline的一个内部类DefaultChannelPipeline$HeadContext，而Unsafe是HeadContext的一个成员变量，HeadContext构造方法如下： 1234567private final Unsafe unsafe;HeadContext(DefaultChannelPipeline pipeline) &#123; super(pipeline, null, HEAD_NAME, false, true); unsafe = pipeline.channel().unsafe(); setAddComplete();&#125; ​ 正如之前讲的HeadContext是AbstractChannelHandlerContext的一个泛化类，再看一下AbstractChannelHandlerContext的构造方法： 12345678AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, boolean inbound, boolean outbound) &#123; this.name = ObjectUtil.checkNotNull(name, "name"); this.pipeline = pipeline; this.executor = executor; this.inbound = inbound; this.outbound = outbound; // Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor. ordered = executor == null || executor instanceof OrderedEventExecutor; ​ 可以看到HeadContext是一个inBound为false，outbound为true，如表格中展示的一样。 由上面的分析可知，最终绑定端口的是HeadContext发起的。 分析Unsafe实例化过程​ 首先Unsafe是Channel是一个内部接口，其初始化是在AbstractChannel初始化的时候实例化的，现在是对Unsafe的初步认知，之前并没有过多的接分析。 ​ Unsafe是一个内部接口，不对外提供接口，那么看一下Unsafe的初始化过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * Creates a new instance. * * @param parent * the parent of this channel. &#123;@code null&#125; if there's no parent. */protected AbstractChannel(Channel parent) &#123; this.parent = parent; id = newId(); unsafe = newUnsafe(); pipeline = newChannelPipeline();&#125;// AbstractChannel的子类AbstractNioMessageChannel实现的newUnsafe方法@Overrideprotected AbstractNioUnsafe newUnsafe() &#123; return new NioMessageUnsafe();&#125;// NioMessageUnsafe是AbstractNioMessageChannel一个内部类private final class NioMessageUnsafe extends AbstractNioUnsafe &#123; private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;(); @Override public void read() &#123; assert eventLoop().inEventLoop(); final ChannelConfig config = config(); final ChannelPipeline pipeline = pipeline(); final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle(); allocHandle.reset(config); boolean closed = false; Throwable exception = null; try &#123; try &#123; do &#123; int localRead = doReadMessages(readBuf); if (localRead == 0) &#123; break; &#125; if (localRead &lt; 0) &#123; closed = true; break; &#125; allocHandle.incMessagesRead(localRead); &#125; while (allocHandle.continueReading()); &#125; catch (Throwable t) &#123; exception = t; &#125; int size = readBuf.size(); for (int i = 0; i &lt; size; i ++) &#123; readPending = false; pipeline.fireChannelRead(readBuf.get(i)); &#125; readBuf.clear(); allocHandle.readComplete(); pipeline.fireChannelReadComplete(); if (exception != null) &#123; closed = closeOnReadError(exception); pipeline.fireExceptionCaught(exception); &#125; if (closed) &#123; inputShutdown = true; if (isOpen()) &#123; close(voidPromise()); &#125; &#125; &#125; finally &#123; // Check if there is a readPending which was not processed yet. // This could be for two reasons: // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method // // See https://github.com/netty/netty/issues/2254 if (!readPending &amp;&amp; !config.isAutoRead()) &#123; removeReadOp(); &#125; &#125; &#125;&#125; Unsafe和Channel对比 由上图可以看到Unsafe和Channel的关系几乎是一一对应的。 看一下在定义Unsafe接口的描述： Unsafe operations that should never be called from user-code. These methods are only provided to implement the actual transport, and must be invoked from an I/O thread except following methods: Unsafe#localAddress() Unsafe#remoteAddress() Unsafe#closeForcibly() Unsafe#register(EventLoop, ChannelPromise) Unsafe#deregister(ChannelPromise) Unsafe#voidPromise() 这是一个内部的接口，不会对外的提供服务。 以上就是Unsafe接口的实例化过程。最终由AbstractNioMessageChannel#newUnsafe()实现Unsafe的初始化，最终实现的类：NioMessageUnsafe。 DefaultChannelPipeline$HeadContext#bind()方法调用的是Unsafe中的bind()方法，这个方法是在AbstractUnsafe中#bind方法： 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123; assertEventLoop(); if (!promise.setUncancellable() || !ensureOpen(promise)) &#123; return; &#125; // See: https://github.com/netty/netty/issues/576 if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp; localAddress instanceof InetSocketAddress &amp;&amp; !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp; !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123; // Warn a user about the fact that a non-root user can't receive a // broadcast packet on *nix if the socket is bound on non-wildcard address. logger.warn( "A non-root user can't receive a broadcast packet if the socket " + "is not bound to a wildcard address; binding to a non-wildcard " + "address (" + localAddress + ") anyway as requested."); &#125; boolean wasActive = isActive(); try &#123; doBind(localAddress); &#125; catch (Throwable t) &#123; safeSetFailure(promise, t); closeIfClosed(); return; &#125; if (!wasActive &amp;&amp; isActive()) &#123; invokeLater(new Runnable() &#123; @Override public void run() &#123; pipeline.fireChannelActive(); &#125; &#125;); &#125; safeSetSuccess(promise);&#125; 而最终doBind()则是NioServerSocketChannel实例化方法： 12345678@Overrideprotected void doBind(SocketAddress localAddress) throws Exception &#123; if (PlatformDependent.javaVersion() &gt;= 7) &#123; javaChannel().bind(localAddress, config.getBacklog()); &#125; else &#123; javaChannel().socket().bind(localAddress, config.getBacklog()); &#125;&#125; 至此则最终实现了端口的绑定。 NioServerSocketChannel#bind()进行端口绑定，这个是最终的结论。]]></content>
      <categories>
        <category>Java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty启动与JavaNio启动比对]]></title>
    <url>%2F2017%2F12%2F31%2Fnetty%E5%90%AF%E5%8A%A8%E4%B8%8Ejava%20nio%E5%90%AF%E5%8A%A8%E5%AF%B9%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[[TOC] netty启动与JavaNio启动比对​ 这是一个netty启动和JavaNio启动一个Socket服务的简单对比，不包含详细的分析，提供自己对Netty的简单的分析。 开启一个服务套接字ServerSocketChannel在Netty中主要使用的类：NioServerSocketChannel JavaNio开启一个服务套接字通道SocketChannel1ServerSocketChannel ssc = ServerSocketChannel.open(); ​ ServerSocketChannel.open()的内部实现使用的是SelectorProvider.provider()的方法进行实现一个SelectorProvicer的单例 1ServerSocketChannel channel = SelectorProvider.provider().openServerSocketChannel() Netty开启一个服务套接字通道的方式​ 在NioServerSocketChannel中组合一个SelectorProvider，直接SelectorProvider.provider();进行初始化 NioServerSocketChannel提供一个默认的构造方法 123456789// NioServerSocketChannel实现了一个默认的SelectorProvider，这是一个单例private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider()/** * Create a new instance */public NioServerSocketChannel() &#123; this(newSocket(DEFAULT_SELECTOR_PROVIDER));&#125; 1234567891011121314private static ServerSocketChannel newSocket(SelectorProvider provider) &#123; try &#123; /** * Use the &#123;@link SelectorProvider&#125; to open &#123;@link SocketChannel&#125; and so remove condition in * &#123;@link SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise. * * See &lt;a href="https://github.com/netty/netty/issues/2308"&gt;#2308&lt;/a&gt;. */ return provider.openServerSocketChannel(); &#125; catch (IOException e) &#123; throw new ChannelException( "Failed to open a server socket.", e); &#125;&#125; ​ 当看到openServerSocketChannel()方法的时候发现Netty也是通过java nio提供的SelectorProvicer提供单例方式实现一个服务套接字的 开启一个服务套接字SelectorJavaNio开启一个服务套接字通道Selectorjava nio通过开启一个selector进行多路复用选择器 1selector = Selector.open(); 查询Selector源码发现也是一个Selector.Provider()开启一个Selector 12345678910111213141516/** * Opens a selector. * * &lt;p&gt; The new selector is created by invoking the &#123;@link * java.nio.channels.spi.SelectorProvider#openSelector openSelector&#125; method * of the system-wide default &#123;@link * java.nio.channels.spi.SelectorProvider&#125; object. &lt;/p&gt; * * @return A new selector * * @throws IOException * If an I/O error occurs */public static Selector open() throws IOException &#123; return SelectorProvider.provider().openSelector();&#125; Netty开启一个服务套接字通道的方式​ 主要使用的类：NioEventLoopGroup、MultithreadEventLoopGroup、MultithreadEventExecutorGroup、NioEventLoop，NioEventLoop$SelectorTuple，NioEventLoop#openSelector 在openSelector方法中开启一个新的Selector，其中provider是一个Selector.Provider(); 1unwrappedSelector = provider.openSelector() 在NioEventLoop中组合了一个private final SelectorProvider provider; NioEventLoop构造方法 12345NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) 在这个构造方法调用了一个openSelector方法，查看一个这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private SelectorTuple openSelector() &#123; final Selector unwrappedSelector; try &#123; unwrappedSelector = provider.openSelector(); &#125; catch (IOException e) &#123; throw new ChannelException("failed to open a new selector", e); &#125; if (DISABLE_KEYSET_OPTIMIZATION) &#123; return new SelectorTuple(unwrappedSelector); &#125; final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet(); Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; try &#123; return Class.forName( "sun.nio.ch.SelectorImpl", false, PlatformDependent.getSystemClassLoader()); &#125; catch (Throwable cause) &#123; return cause; &#125; &#125; &#125;); if (!(maybeSelectorImplClass instanceof Class) || // ensure the current selector implementation is what we can instrument. !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) &#123; if (maybeSelectorImplClass instanceof Throwable) &#123; Throwable t = (Throwable) maybeSelectorImplClass; logger.trace("failed to instrument a special java.util.Set into: &#123;&#125;", unwrappedSelector, t); &#125; return new SelectorTuple(unwrappedSelector); &#125; final Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass; Object maybeException = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; try &#123; Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys"); Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys"); Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField); if (cause != null) &#123; return cause; &#125; cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField); if (cause != null) &#123; return cause; &#125; selectedKeysField.set(unwrappedSelector, selectedKeySet); publicSelectedKeysField.set(unwrappedSelector, selectedKeySet); return null; &#125; catch (NoSuchFieldException e) &#123; return e; &#125; catch (IllegalAccessException e) &#123; return e; &#125; &#125; &#125;); if (maybeException instanceof Exception) &#123; selectedKeys = null; Exception e = (Exception) maybeException; logger.trace("failed to instrument a special java.util.Set into: &#123;&#125;", unwrappedSelector, e); return new SelectorTuple(unwrappedSelector); &#125; selectedKeys = selectedKeySet; logger.trace("instrumented a special java.util.Set into: &#123;&#125;", unwrappedSelector); return new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));&#125; ​ 这个方法中有一段代码：unwrappedSelector = provider.openSelector();这个就是在java nio中使用这provider的openSelector(); ​ 如何使用NioEventLoop类的呢，这需要了解reactor模型，这是一个基础概念的问题，在这里不进行说明，后继会加入对reactor描述，这里仅仅知道就可以了。 ​ 在实现一个ServerSocket的时候会初始化一个NioEventLoopGroup，可以是两个，一个作为reactor中的accept，一个作为io的read或者write 123456// 多线程模型,accetp作为main reactor// main reactor是一个单线程int nThreads = 1;EventLoopGroup parentGroup = new NioEventLoopGroup(nThreads);// sub reactor中一个多线程EventLoopGroup childGroup = new NioEventLoopGroup(); 看一个EventLoopGroup的类图，只画出关键的类图 ​ 在MultithreadEventExecutorGroup构造方法中调用newChild方法，实例化一个NioEventLoop并存放于children中 查看MultithreadEventExecutorGroup的构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Create a new instance. * * @param nThreads the number of threads that will be used by this instance. * @param executor the Executor to use, or &#123;@code null&#125; if the default should be used. * @param chooserFactory the &#123;@link EventExecutorChooserFactory&#125; to use. * @param args arguments which will passed to each &#123;@link #newChild(Executor, Object...)&#125; call */protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123; if (nThreads &lt;= 0) &#123; throw new IllegalArgumentException(String.format("nThreads: %d (expected: &gt; 0)", nThreads)); &#125; if (executor == null) &#123; executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); &#125; children = new EventExecutor[nThreads]; for (int i = 0; i &lt; nThreads; i ++) &#123; boolean success = false; try &#123; children[i] = newChild(executor, args); success = true; &#125; catch (Exception e) &#123; // TODO: Think about if this is a good exception type throw new IllegalStateException("failed to create a child event loop", e); &#125; finally &#123; if (!success) &#123; for (int j = 0; j &lt; i; j ++) &#123; children[j].shutdownGracefully(); &#125; for (int j = 0; j &lt; i; j ++) &#123; EventExecutor e = children[j]; try &#123; while (!e.isTerminated()) &#123; e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS); &#125; &#125; catch (InterruptedException interrupted) &#123; // Let the caller handle the interruption. Thread.currentThread().interrupt(); break; &#125; &#125; &#125; &#125; &#125; chooser = chooserFactory.newChooser(children); final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123; @Override public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123; if (terminatedChildren.incrementAndGet() == children.length) &#123; terminationFuture.setSuccess(null); &#125; &#125; &#125;; for (EventExecutor e: children) &#123; e.terminationFuture().addListener(terminationListener); &#125; Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length); Collections.addAll(childrenSet, children); readonlyChildren = Collections.unmodifiableSet(childrenSet);&#125; ​ 当然这个构造方法中有很多的其它操作，但是在看源码中先关注脉络，再看细节，不要掉一个小的细节中出不来，就没有办法再看下去了；因此这段代码中我们只需要关注children[i] = newChild(executor, args);这个方法即可。 ​ 这个方法在类图中有newChild展示方法，这个方法最终实现类是NioEventLoopGroup，这里具体查看一下： 12345@Overrideprotected EventLoop newChild(Executor executor, Object... args) throws Exception &#123; return new NioEventLoop(this, executor, (SelectorProvider) args[0], ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);&#125; ​ 是的，这个方法有没有比较熟悉，对，这个就是开头讲的那个构造方法，到此时为止，完全明白了netty是如何开启一个selector的了，代码内部和java nio开启selector并没有太大的差别。 ​ 到目前为止了解了netty是如何开启一个NioServerSocketChannel的与启用一个Selector的。 将channel注册到selector中JavaNio将一个ServerSocketChannel注册到Selector中​ 将一个ServerSocketChannel注册到一个Selector，由于两个Open内部都使用了SelectorProvider.provider();这个方法是单例的，因此使用的是一个SelectorProvider 123456789101112/*** 这是第一步开启的一个ServerSocketChannel*/ServerSocketChannel ssc = ServerSocketChannel.open();/*** 这是第二步打开一个Selector*/Selector selector = Selector.open();/*** 把一个ServerSocketChannel注册到一个Selector*/ssc.register(selector, SelectionKey.OP_ACCEPT); Netty是如何注册一个ServerSocketChannel的呢？​ 需要查看实现一个ServerSocket需要的步骤： 1234567891011121314151617181920212223// Configure the server.// 多线程模型int nThreads = 1;EventLoopGroup parentGroup = new NioEventLoopGroup(nThreads);EventLoopGroup childGroup = new NioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(parentGroup, childGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new EchoServerChannelInitializer()); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync();&#125; finally &#123; // Shut down all event loops to terminate all threads. parentGroup.shutdownGracefully(); childGroup.shutdownGracefully();&#125; ​ 这就是实现一个ServerSocket的方法，查看bind方法：AbstractBootstrap—&gt;ServerBootstrap，bind为AbstractBootstrap中的一个方法，最终调用的是initAndRegister()方法，需要详细的看一下这个方法： 12345// 成员变量// ReflectiveChannelFactoryprivate volatile ChannelFactory&lt;? extends C&gt; channelFactory;在initAndRegister方法实例化了一个channel，这个channel中NioServerSocketChannel的实例channel = channelFactory.newChannel(); ​ 查看完整的initAndRegister方法 1234567891011121314151617181920212223242526272829303132333435final ChannelFuture initAndRegister() &#123; Channel channel = null; try &#123; // 成员变量实例化一个NioServerSocketChannel channel = channelFactory.newChannel(); init(channel); &#125; catch (Throwable t) &#123; if (channel != null) &#123; // channel can be null if newChannel crashed (eg SocketException("too many open files")) channel.unsafe().closeForcibly(); &#125; // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t); &#125; // group为NioEventLoopGroup，即为MultithreadEventLoopGroup ChannelFuture regFuture = config().group().register(channel); if (regFuture.cause() != null) &#123; if (channel.isRegistered()) &#123; channel.close(); &#125; else &#123; channel.unsafe().closeForcibly(); &#125; &#125; // If we are here and the promise is not failed, it's one of the following cases: // 1) If we attempted registration from the event loop, the registration has been completed at this point. // i.e. It's safe to attempt bind() or connect() now because the channel has been registered. // 2) If we attempted registration from the other thread, the registration request has been successfully // added to the event loop's task queue for later execution. // i.e. It's safe to attempt bind() or connect() now: // because bind() or connect() will be executed *after* the scheduled registration task is executed // because register(), bind(), and connect() are all bound to the same thread. return regFuture;&#125; ​ ​ 调用register方法，最终调用的是AbstractChannel的register进行channel注册到EventLoop当中。 ​ AbstractChannel中包含一个EventLoop，即一个channel只属于一个EventLoop，即把channel分配给相应的EventLoop（同时一个EventLoop只能交由一个Thread进行处理，当然这个后继会说明）EventLoop最终实现的是Executor接口，此接口中只有execute()方法，即提交一个Runnable进行执行。 ​ 在SingleThreadEventLoop执行一个task任务，同步调用SingleTheadEventExecutor#executor()并执行异步执行Runnable方法进行注册操作，此时不对同步调用executor方法进行分析，留做下面再介绍（在看代码时先注重脉络再关注细节）。 123456eventLoop.execute(new Runnable() &#123; @Override public void run() &#123; register0(promise); &#125;&#125;); ​ 在AbstractChannel中有一个空实现的方法，AbstractChannel#doRegister();具体的实现在AbstractNioChannel中，再查看这个方法： 123456789101112131415161718192021@Overrideprotected void doRegister() throws Exception &#123; boolean selected = false; for (;;) &#123; try &#123; selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this); return; &#125; catch (CancelledKeyException e) &#123; if (!selected) &#123; // Force the Selector to select now as the "canceled" SelectionKey may still be // cached and not removed because no Select.select(..) operation was called yet. eventLoop().selectNow(); selected = true; &#125; else &#123; // We forced a select operation on the selector before but the SelectionKey is still cached // for whatever reason. JDK bug ? throw e; &#125; &#125; &#125;&#125; ​ 是的，最终的注册在doRegister中：javaChannel().register(eventLoop().unwrappedSelector(), 0, this); ​ 回头查看java nio channel注册的方式： 1234/*** 把一个ServerSocketChannel注册到一个Selector*/ssc.register(selector, SelectionKey.OP_ACCEPT); ​ 此时完成把channel注册到selector中 。 ​ 再来看一个序列图： ​ 可以看到在AbstractChannel的register0开启一个线程进行注册操作。 123456789101112131415161718192021222324252627282930313233343536373839private void register0(ChannelPromise promise) &#123; try &#123; // check if the channel is still open as it could be closed in the mean time when the register // call was outside of the eventLoop if (!promise.setUncancellable() || !ensureOpen(promise)) &#123; return; &#125; boolean firstRegistration = neverRegistered; doRegister(); neverRegistered = false; registered = true; // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the // user may already fire events through the pipeline in the ChannelFutureListener. // 调用handler可以添加到双向链表的操作 pipeline.invokeHandlerAddedIfNeeded(); safeSetSuccess(promise); pipeline.fireChannelRegistered(); // Only fire a channelActive if the channel has never been registered. This prevents firing // multiple channel actives if the channel is deregistered and re-registered. if (isActive()) &#123; if (firstRegistration) &#123; pipeline.fireChannelActive(); &#125; else if (config().isAutoRead()) &#123; // This channel was registered before and autoRead() is set. This means we need to begin read // again so that we process inbound data. // // See https://github.com/netty/netty/issues/4805 beginRead(); &#125; &#125; &#125; catch (Throwable t) &#123; // Close the channel directly to avoid FD leak. closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); &#125;&#125; ​ 调用DefaultChannelPipeline#fireChannelRegistered();开启channel register操作，之后的ChannelInitializer可进行注册，至于注册的方式后继会单独分析。 ​ 还是需要查看一下DefaultChannelPipeline#fireChannelRegistered();的方法的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final void invokeHandlerAddedIfNeeded() &#123; assert channel.eventLoop().inEventLoop(); if (firstRegistration) &#123; firstRegistration = false; // We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers, // that were added before the registration was done. callHandlerAddedForAllHandlers(); &#125;&#125;private void callHandlerAddedForAllHandlers() &#123; final PendingHandlerCallback pendingHandlerCallbackHead; synchronized (this) &#123; assert !registered; // This Channel itself was registered. registered = true; pendingHandlerCallbackHead = this.pendingHandlerCallbackHead; // Null out so it can be GC'ed. this.pendingHandlerCallbackHead = null; &#125; // This must happen outside of the synchronized(...) block as otherwise handlerAdded(...) may be called while // holding the lock and so produce a deadlock if handlerAdded(...) will try to add another handler from outside // the EventLoop. PendingHandlerCallback task = pendingHandlerCallbackHead; while (task != null) &#123; // 启动handler的注册 task.execute(); task = task.next; &#125;&#125;// 这是DefaultChannelPipeline的一个内部类，用于等候handler的注册，这个类在以后会用到private abstract static class PendingHandlerCallback implements Runnable &#123; final AbstractChannelHandlerContext ctx; PendingHandlerCallback next; PendingHandlerCallback(AbstractChannelHandlerContext ctx) &#123; this.ctx = ctx; &#125; abstract void execute();&#125;private final class PendingHandlerAddedTask extends PendingHandlerCallback &#123; PendingHandlerAddedTask(AbstractChannelHandlerContext ctx) &#123; super(ctx); &#125; @Override public void run() &#123; callHandlerAdded0(ctx); &#125; @Override void execute() &#123; EventExecutor executor = ctx.executor(); if (executor.inEventLoop()) &#123; callHandlerAdded0(ctx); &#125; else &#123; try &#123; executor.execute(this); &#125; catch (RejectedExecutionException e) &#123; if (logger.isWarnEnabled()) &#123; logger.warn( "Can't invoke handlerAdded() as the EventExecutor &#123;&#125; rejected it, removing handler &#123;&#125;.", executor, ctx.name(), e); &#125; remove0(ctx); ctx.setRemoved(); &#125; &#125; &#125;&#125; 在callHandlerAddedForAllHandlers方法当中有一个参数：registered，这个参数的注释是： Set to {@code true} once the {@link AbstractChannel} is registered.Once set to {@code true} the value will never change. 在registered设置为true可以进行一系列的操作，这个在以后会使用到。 在循环中有Selector进行select操作，进行事件监听java nio 进行selector进行select等待及事件处理​ 此处仅仅是对java nio channel进行初步了解，不做细节的分析，后继会进行细节分析。 123456789101112131415161718192021222324252627while (!Thread.currentThread().isInterrupted()) &#123; System.err.println("selector"); // select()阻塞，等待有事件发生唤醒 // 等待处理新的事件; // 一直阻塞直到下一个事件到来才唤醒. // 此方法执行处于阻塞模式的选择操作。 // 仅在至少选择一个通道、调用此选择器的 wakeup 方法，或者当前的线程已中断（以先到者为准）后此方法才返回。 selector.select(); System.err.println("selector…………"); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (!key.isValid()) &#123; System.err.println("check……"); continue; &#125; if (key.isAcceptable()) &#123; accept(key); &#125; else if (key.isReadable()) &#123; read(key); &#125; else if (key.isWritable()) &#123; write(key); &#125; keyIterator.remove(); //该事件已经处理，可以丢弃 &#125;&#125; Netty是如何进行select的呢？​ 先回顾channel是如何进行注册，在SingleThreadEventLoop执行了一个executor方法，是的，现在回头再看executor()会亲切一点，同时回答之前一个问题，SingleThreadEventLoop#register()方法中的线程什么时候start()呢？ 12345678910111213141516171819202122232425/*** @param task 这是一个注册channel到register的线程*/@Overridepublic void execute(Runnable task) &#123; if (task == null) &#123; throw new NullPointerException("task"); &#125; // 判断是不是一个event loop线程，即reactor中的acceptor线程 // 初始化时并不是一个eventloop的线程 boolean inEventLoop = inEventLoop(); if (inEventLoop) &#123; addTask(task); &#125; else &#123; startThread(); addTask(task); if (isShutdown() &amp;&amp; removeTask(task)) &#123; reject(); &#125; &#125; if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123; wakeup(inEventLoop); &#125;&#125; 先看SingleThreadEventLoop#startThread(); 1SingleThreadEventExecutor.this.run(); 这是一个最重要的段代码，即开始启动run这个方法，在SingleThreadEventExecutor中的run是一个抽象方法，查看具体的实现类：NioEventLoop#run，查看这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Overrideprotected void run() &#123; for (;;) &#123; try &#123; switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123; case SelectStrategy.CONTINUE: continue; case SelectStrategy.SELECT: // 事件等待，对应java nio中的select操作 select(wakenUp.getAndSet(false)); // 'wakenUp.compareAndSet(false, true)' is always evaluated // before calling 'selector.wakeup()' to reduce the wake-up // overhead. (Selector.wakeup() is an expensive operation.) // // However, there is a race condition in this approach. // The race condition is triggered when 'wakenUp' is set to // true too early. // // 'wakenUp' is set to true too early if: // 1) Selector is waken up between 'wakenUp.set(false)' and // 'selector.select(...)'. (BAD) // 2) Selector is waken up between 'selector.select(...)' and // 'if (wakenUp.get()) &#123; ... &#125;'. (OK) // // In the first case, 'wakenUp' is set to true and the // following 'selector.select(...)' will wake up immediately. // Until 'wakenUp' is set to false again in the next round, // 'wakenUp.compareAndSet(false, true)' will fail, and therefore // any attempt to wake up the Selector will fail, too, causing // the following 'selector.select(...)' call to block // unnecessarily. // // To fix this problem, we wake up the selector again if wakenUp // is true immediately after selector.select(...). // It is inefficient in that it wakes up the selector for both // the first case (BAD - wake-up required) and the second case // (OK - no wake-up required). if (wakenUp.get()) &#123; selector.wakeup(); &#125; // fall through default: &#125; cancelledKeys = 0; needsToSelectAgain = false; final int ioRatio = this.ioRatio; if (ioRatio == 100) &#123; try &#123; // 事件选择操作 processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. runAllTasks(); &#125; &#125; else &#123; final long ioStartTime = System.nanoTime(); try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. final long ioTime = System.nanoTime() - ioStartTime; // 执行任务，这个任务包含executor启动绑定selector的任务 runAllTasks(ioTime * (100 - ioRatio) / ioRatio); &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; // Always handle shutdown even if the loop processing threw an exception. try &#123; if (isShuttingDown()) &#123; closeAll(); if (confirmShutdown()) &#123; return; &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; &#125;&#125; NioEventLoop#run是一个死循环，在run方法中调用select方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private void select(boolean oldWakenUp) throws IOException &#123; Selector selector = this.selector; try &#123; int selectCnt = 0; long currentTimeNanos = System.nanoTime(); long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); for (;;) &#123; long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L; if (timeoutMillis &lt;= 0) &#123; if (selectCnt == 0) &#123; selector.selectNow(); selectCnt = 1; &#125; break; &#125; // If a task was submitted when wakenUp value was true, the task didn't get a chance to call // Selector#wakeup. So we need to check task queue again before executing select operation. // If we don't, the task might be pended until select operation was timed out. // It might be pended until idle timeout if IdleStateHandler existed in pipeline. if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123; selector.selectNow(); selectCnt = 1; break; &#125; int selectedKeys = selector.select(timeoutMillis); selectCnt ++; if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123; // - Selected something, // - waken up by user, or // - the task queue has a pending task. // - a scheduled task is ready for processing break; &#125; if (Thread.interrupted()) &#123; // Thread was interrupted so reset selected keys and break so we not run into a busy loop. // As this is most likely a bug in the handler of the user or it's client library we will // also log it. // // See https://github.com/netty/netty/issues/2426 if (logger.isDebugEnabled()) &#123; logger.debug("Selector.select() returned prematurely because " + "Thread.currentThread().interrupt() was called. Use " + "NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."); &#125; selectCnt = 1; break; &#125; long time = System.nanoTime(); if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123; // timeoutMillis elapsed without anything selected. selectCnt = 1; &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123; // The selector returned prematurely many times in a row. // Rebuild the selector to work around the problem. logger.warn( "Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.", selectCnt, selector); rebuildSelector(); selector = this.selector; // Select again to populate selectedKeys. selector.selectNow(); selectCnt = 1; break; &#125; currentTimeNanos = time; &#125; if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.", selectCnt - 1, selector); &#125; &#125; &#125; catch (CancelledKeyException e) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector &#123;&#125; - JDK bug?", selector, e); &#125; // Harmless exception - log anyway &#125;&#125; select方法是Netty对select的封装。此时完成了select的等待操作。 下面就看task什么时候执行： ​ 在executor方法中调用addTask(task);这是一个Queue，通过Queue进行执行任务，这是一个简单的生产者与消费者，由executor进行生产任务，由runAllTasks进行消费任务，在run中启动任务。 ​ 此时完成了启动绑定的操作。 ​ ==在这一节出现一个重要的类，这个类就是SingleThreadEventExecutor，这个类中有一个Queue，这是一个生产者消费者的容器，用于存储每一个任务，Netty中的任务都是存储在这个Queue中，即一个EventLoop可以执行多个任务。== 在进行Select操作时，需要绑定特定事件，那么Netty是如何绑定事件的呢？​ 在NioEventLoop#run方法中调用processSelectedKey方法，见名可知这是处理select选择器事件的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123; final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); if (!k.isValid()) &#123; final EventLoop eventLoop; try &#123; eventLoop = ch.eventLoop(); &#125; catch (Throwable ignored) &#123; // If the channel implementation throws an exception because there is no event loop, we ignore this // because we are only trying to determine if ch is registered to this event loop and thus has authority // to close ch. return; &#125; // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is // still healthy and should not be closed. // See https://github.com/netty/netty/issues/5125 if (eventLoop != this || eventLoop == null) &#123; return; &#125; // close the channel if the key is not valid anymore unsafe.close(unsafe.voidPromise()); return; &#125; try &#123; int readyOps = k.readyOps(); // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise // the NIO JDK channel implementation may throw a NotYetConnectedException. if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123; // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking // See https://github.com/netty/netty/issues/924 int ops = k.interestOps(); ops &amp;= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect(); &#125; // Process OP_WRITE first as we may be able to write some queued buffers and so free memory. if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write ch.unsafe().forceFlush(); &#125; // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead // to a spin loop if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123; unsafe.read(); &#125; &#125; catch (CancelledKeyException ignored) &#123; unsafe.close(unsafe.voidPromise()); &#125;&#125; 此时可以总结一下：主要的几个类： NioEventLoop： 开启了一个select选择器 进行select等待key的操作 进行事件绑定处理，即通过 AbstractNioChannel channel注册到EventLoop（一个channel只可以绑定一个EventLoop） NioServerSocketChannel 通过SelectorProvider.provider().openServerSocketChannel(); 以上就是Netty中操作与java nio操作的对应关系。 如何绑定端口到NioServerSocketChannel的呢？​ 细心的你会发现，以上的操作并没有绑定端口到ServerSocketChannel中，下面就讲一下端口如何绑定到ServerSocketChannel上的。 ​ 在AbstractBootstrap#doBind()方法中调用AbstractBootstrap#initAndRegister()方法，其实上面讲的全部是这个方法当中的内容，接着回头查看AbstractBootstrap#doBind(); 1234567891011121314151617181920212223242526272829303132333435private ChannelFuture doBind(final SocketAddress localAddress) &#123; final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; if (regFuture.isDone()) &#123; // At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; // Registration future is almost always fulfilled already, but just in case it's not. final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); regFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; Throwable cause = future.cause(); if (cause != null) &#123; // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an // IllegalStateException once we try to access the EventLoop of the Channel. promise.setFailure(cause); &#125; else &#123; // Registration was successful, so set the correct executor to use. // See https://github.com/netty/netty/issues/2586 promise.registered(); doBind0(regFuture, channel, localAddress, promise); &#125; &#125; &#125;); return promise; &#125;&#125; ​ 这个方法当中有一个AbstractBootstrap#doBind0()方法。 1234567891011121314151617private static void doBind0( final ChannelFuture regFuture, final Channel channel, final SocketAddress localAddress, final ChannelPromise promise) &#123; // This method is invoked before channelRegistered() is triggered. Give user handlers a chance to set up // the pipeline in its channelRegistered() implementation. channel.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; if (regFuture.isSuccess()) &#123; channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); &#125; else &#123; promise.setFailure(regFuture.cause()); &#125; &#125; &#125;);&#125; ​ 这里仍然需要回顾之前讲的：在SingleThreadEventExecutor类当中有一个Queue，一个简单的生产者消费者的容器，还记得EventLoop的继承关系吗？在这里再看一下这个类图： ​ 是的，一个NioEventLoop就是一个Executor，可以执行和线程，同时包含一个Queue，一个生产者与消费者的容器。 ​ 在Netty看来绑定端口仍然是一个任务，通过SingleThreadEventExecutor#addTask添加到Queue中，并在NioEventLoop#run启动runAllTasks启动任务。因此只需关注channel中提供的bind方法即可（在这里一定要理解任务任务启动的方式，以及Netty把bind也看作一个task）。 ​ NioServerSocketChannel#doBind(SocketAddress)方法进行绑定IP及port的。 至于怎么调用doBind则是一个比较复杂的操作，有机会再分析。 Netty启动拾遗在AbstractNioChannel#doRegister()注册时： javaChannel().register(eventLoop().unwrappedSelector(), 0, this); NioServerSocketChannel#doBind();绑定端口时： javaChannel().bind(localAddress, config.getBacklog()); 这里两个都是使用的javaChannel();现在分析进行使用javaChannel进行注册和绑定端口 在AbstractNioChannel类以及子类均可以获取SelectableChannel，就是javaChannel(); NioServerSocketChannel#newSocket()方法中通过SelectorProvider.provider().openServerSocketChannel();]]></content>
      <categories>
        <category>Java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
</search>
