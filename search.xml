<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[netty]]></title>
    <url>%2F2017%2F12%2F31%2Fnetty%2F</url>
    <content type="text"><![CDATA[Netty学习netty启动与JavaNio启动比对​ 这是一个netty启动和JavaNio启动一个Socket服务的简单对比，不包含详细的分析，提供自己对Netty的简单的分析。 开启一个服务套接字ServerSocketChannel在Netty中主要使用的类：NioServerSocketChannel JavaNio开启一个服务套接字通道SocketChannel1ServerSocketChannel ssc = ServerSocketChannel.open(); ​ ServerSocketChannel.open()的内部实现使用的是SelectorProvider.provider()的方法进行实现一个SelectorProvicer的单例 1ServerSocketChannel channel = SelectorProvider.provider().openServerSocketChannel() Netty开启一个服务套接字通道的方式​ 在NioServerSocketChannel中组合一个SelectorProvider，直接SelectorProvider.provider();进行初始化 NioServerSocketChannel提供一个默认的构造方法 123456789// NioServerSocketChannel实现了一个默认的SelectorProvider，这是一个单例private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider()/** * Create a new instance */public NioServerSocketChannel() &#123; this(newSocket(DEFAULT_SELECTOR_PROVIDER));&#125; 1234567891011121314private static ServerSocketChannel newSocket(SelectorProvider provider) &#123; try &#123; /** * Use the &#123;@link SelectorProvider&#125; to open &#123;@link SocketChannel&#125; and so remove condition in * &#123;@link SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise. * * See &lt;a href="https://github.com/netty/netty/issues/2308"&gt;#2308&lt;/a&gt;. */ return provider.openServerSocketChannel(); &#125; catch (IOException e) &#123; throw new ChannelException( "Failed to open a server socket.", e); &#125;&#125; ​ 当看到openServerSocketChannel()方法的时候发现Netty也是通过java nio提供的SelectorProvicer提供单例方式实现一个服务套接字的 开启一个服务套接字SelectorJavaNio开启一个服务套接字通道Selectorjava nio通过开启一个selector进行多路复用选择器 1selector = Selector.open(); 查询Selector源码发现也是一个Selector.Provider()开启一个Selector 12345678910111213141516/** * Opens a selector. * * &lt;p&gt; The new selector is created by invoking the &#123;@link * java.nio.channels.spi.SelectorProvider#openSelector openSelector&#125; method * of the system-wide default &#123;@link * java.nio.channels.spi.SelectorProvider&#125; object. &lt;/p&gt; * * @return A new selector * * @throws IOException * If an I/O error occurs */public static Selector open() throws IOException &#123; return SelectorProvider.provider().openSelector();&#125; Netty开启一个服务套接字通道的方式​ 主要使用的类：NioEventLoopGroup、MultithreadEventLoopGroup、MultithreadEventExecutorGroup、NioEventLoop，NioEventLoop$SelectorTuple，NioEventLoop#openSelector 在openSelector方法中开启一个新的Selector，其中provider是一个Selector.Provider(); 1unwrappedSelector = provider.openSelector() 在NioEventLoop中组合了一个private final SelectorProvider provider; NioEventLoop构造方法 12345NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) 在这个构造方法调用了一个openSelector方法，查看一个这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private SelectorTuple openSelector() &#123; final Selector unwrappedSelector; try &#123; unwrappedSelector = provider.openSelector(); &#125; catch (IOException e) &#123; throw new ChannelException("failed to open a new selector", e); &#125; if (DISABLE_KEYSET_OPTIMIZATION) &#123; return new SelectorTuple(unwrappedSelector); &#125; final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet(); Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; try &#123; return Class.forName( "sun.nio.ch.SelectorImpl", false, PlatformDependent.getSystemClassLoader()); &#125; catch (Throwable cause) &#123; return cause; &#125; &#125; &#125;); if (!(maybeSelectorImplClass instanceof Class) || // ensure the current selector implementation is what we can instrument. !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) &#123; if (maybeSelectorImplClass instanceof Throwable) &#123; Throwable t = (Throwable) maybeSelectorImplClass; logger.trace("failed to instrument a special java.util.Set into: &#123;&#125;", unwrappedSelector, t); &#125; return new SelectorTuple(unwrappedSelector); &#125; final Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass; Object maybeException = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; try &#123; Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys"); Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys"); Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField); if (cause != null) &#123; return cause; &#125; cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField); if (cause != null) &#123; return cause; &#125; selectedKeysField.set(unwrappedSelector, selectedKeySet); publicSelectedKeysField.set(unwrappedSelector, selectedKeySet); return null; &#125; catch (NoSuchFieldException e) &#123; return e; &#125; catch (IllegalAccessException e) &#123; return e; &#125; &#125; &#125;); if (maybeException instanceof Exception) &#123; selectedKeys = null; Exception e = (Exception) maybeException; logger.trace("failed to instrument a special java.util.Set into: &#123;&#125;", unwrappedSelector, e); return new SelectorTuple(unwrappedSelector); &#125; selectedKeys = selectedKeySet; logger.trace("instrumented a special java.util.Set into: &#123;&#125;", unwrappedSelector); return new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));&#125; ​ 这个方法中有一段代码：unwrappedSelector = provider.openSelector();这个就是在java nio中使用这provider的openSelector(); ​ 如何使用NioEventLoop类的呢，这需要了解reactor模型，这是一个基础概念的问题，在这里不进行说明，后继会加入对reactor描述，这里仅仅知道就可以了。 ​ 在实现一个ServerSocket的时候会初始化一个NioEventLoopGroup，可以是两个，一个作为reactor中的accept，一个作为io的read或者write 123456// 多线程模型,accetp作为main reactor// main reactor是一个单线程int nThreads = 1;EventLoopGroup parentGroup = new NioEventLoopGroup(nThreads);// sub reactor中一个多线程EventLoopGroup childGroup = new NioEventLoopGroup(); 看一个EventLoopGroup的类图，只画出关键的类图 ​ 在MultithreadEventExecutorGroup构造方法中调用newChild方法，实例化一个NioEventLoop并存放于children中 查看MultithreadEventExecutorGroup的构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Create a new instance. * * @param nThreads the number of threads that will be used by this instance. * @param executor the Executor to use, or &#123;@code null&#125; if the default should be used. * @param chooserFactory the &#123;@link EventExecutorChooserFactory&#125; to use. * @param args arguments which will passed to each &#123;@link #newChild(Executor, Object...)&#125; call */protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123; if (nThreads &lt;= 0) &#123; throw new IllegalArgumentException(String.format("nThreads: %d (expected: &gt; 0)", nThreads)); &#125; if (executor == null) &#123; executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); &#125; children = new EventExecutor[nThreads]; for (int i = 0; i &lt; nThreads; i ++) &#123; boolean success = false; try &#123; children[i] = newChild(executor, args); success = true; &#125; catch (Exception e) &#123; // TODO: Think about if this is a good exception type throw new IllegalStateException("failed to create a child event loop", e); &#125; finally &#123; if (!success) &#123; for (int j = 0; j &lt; i; j ++) &#123; children[j].shutdownGracefully(); &#125; for (int j = 0; j &lt; i; j ++) &#123; EventExecutor e = children[j]; try &#123; while (!e.isTerminated()) &#123; e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS); &#125; &#125; catch (InterruptedException interrupted) &#123; // Let the caller handle the interruption. Thread.currentThread().interrupt(); break; &#125; &#125; &#125; &#125; &#125; chooser = chooserFactory.newChooser(children); final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123; @Override public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123; if (terminatedChildren.incrementAndGet() == children.length) &#123; terminationFuture.setSuccess(null); &#125; &#125; &#125;; for (EventExecutor e: children) &#123; e.terminationFuture().addListener(terminationListener); &#125; Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length); Collections.addAll(childrenSet, children); readonlyChildren = Collections.unmodifiableSet(childrenSet);&#125; ​ 当然这个构造方法中有很多的其它操作，但是在看源码中先关注脉络，再看细节，不要掉一个小的细节中出不来，就没有办法再看下去了；因此这段代码中我们只需要关注children[i] = newChild(executor, args);这个方法即可。 ​ 这个方法在类图中有newChild展示方法，这个方法最终实现类是NioEventLoopGroup，这里具体查看一下： 12345@Overrideprotected EventLoop newChild(Executor executor, Object... args) throws Exception &#123; return new NioEventLoop(this, executor, (SelectorProvider) args[0], ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);&#125; ​ 是的，这个方法有没有比较熟悉，对，这个就是开头讲的那个构造方法，到此时为止，完全明白了netty是如何开启一个selector的了，代码内部和java nio开启selector并没有太大的差别。 ​ 到目前为止了解了netty是如何开启一个NioServerSocketChannel的与启用一个Selector的。 将channel注册到selector中JavaNio将一个ServerSocketChannel注册到Selector中​ 将一个ServerSocketChannel注册到一个Selector，由于两个Open内部都使用了SelectorProvider.provider();这个方法是单例的，因此使用的是一个SelectorProvider 123456789101112/*** 这是第一步开启的一个ServerSocketChannel*/ServerSocketChannel ssc = ServerSocketChannel.open();/*** 这是第二步打开一个Selector*/Selector selector = Selector.open();/*** 把一个ServerSocketChannel注册到一个Selector*/ssc.register(selector, SelectionKey.OP_ACCEPT); Netty是如何注册一个ServerSocketChannel的呢？​ 需要查看实现一个ServerSocket需要的步骤： 1234567891011121314151617181920212223// Configure the server.// 多线程模型int nThreads = 1;EventLoopGroup parentGroup = new NioEventLoopGroup(nThreads);EventLoopGroup childGroup = new NioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(parentGroup, childGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new EchoServerChannelInitializer()); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync();&#125; finally &#123; // Shut down all event loops to terminate all threads. parentGroup.shutdownGracefully(); childGroup.shutdownGracefully();&#125; ​ 这就是实现一个ServerSocket的方法，查看bind方法：AbstractBootstrap—&gt;ServerBootstrap，bind为AbstractBootstrap中的一个方法，最终调用的是initAndRegister()方法，需要详细的看一下这个方法： 12345// 成员变量// ReflectiveChannelFactoryprivate volatile ChannelFactory&lt;? extends C&gt; channelFactory;在initAndRegister方法实例化了一个channel，这个channel中NioServerSocketChannel的实例channel = channelFactory.newChannel(); ​ 查看完整的initAndRegister方法 1234567891011121314151617181920212223242526272829303132333435final ChannelFuture initAndRegister() &#123; Channel channel = null; try &#123; // 成员变量实例化一个NioServerSocketChannel channel = channelFactory.newChannel(); init(channel); &#125; catch (Throwable t) &#123; if (channel != null) &#123; // channel can be null if newChannel crashed (eg SocketException("too many open files")) channel.unsafe().closeForcibly(); &#125; // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t); &#125; // group为NioEventLoopGroup，即为MultithreadEventLoopGroup ChannelFuture regFuture = config().group().register(channel); if (regFuture.cause() != null) &#123; if (channel.isRegistered()) &#123; channel.close(); &#125; else &#123; channel.unsafe().closeForcibly(); &#125; &#125; // If we are here and the promise is not failed, it's one of the following cases: // 1) If we attempted registration from the event loop, the registration has been completed at this point. // i.e. It's safe to attempt bind() or connect() now because the channel has been registered. // 2) If we attempted registration from the other thread, the registration request has been successfully // added to the event loop's task queue for later execution. // i.e. It's safe to attempt bind() or connect() now: // because bind() or connect() will be executed *after* the scheduled registration task is executed // because register(), bind(), and connect() are all bound to the same thread. return regFuture;&#125; ​ ​ 调用register方法，最终调用的是AbstractChannel的register进行channel注册到EventLoop当中。 ​ AbstractChannel中包含一个EventLoop，即一个channel只属于一个EventLoop，即把channel分配给相应的EventLoop（同时一个EventLoop只能交由一个Thread进行处理，当然这个后继会说明）EventLoop最终实现的是Executor接口，此接口中只有execute()方法，即提交一个Runnable进行执行。 ​ 在SingleThreadEventLoop执行一个task任务，同步调用SingleTheadEventExecutor#executor()并执行异步执行Runnable方法进行注册操作，此时不对同步调用executor方法进行分析，留做下面再介绍（在看代码时先注重脉络再关注细节）。 123456eventLoop.execute(new Runnable() &#123; @Override public void run() &#123; register0(promise); &#125;&#125;); ​ 在AbstractChannel中有一个空实现的方法，AbstractChannel#doRegister();具体的实现在AbstractNioChannel中，再查看这个方法： 123456789101112131415161718192021@Overrideprotected void doRegister() throws Exception &#123; boolean selected = false; for (;;) &#123; try &#123; selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this); return; &#125; catch (CancelledKeyException e) &#123; if (!selected) &#123; // Force the Selector to select now as the "canceled" SelectionKey may still be // cached and not removed because no Select.select(..) operation was called yet. eventLoop().selectNow(); selected = true; &#125; else &#123; // We forced a select operation on the selector before but the SelectionKey is still cached // for whatever reason. JDK bug ? throw e; &#125; &#125; &#125;&#125; ​ 是的，最终的注册在doRegister中：javaChannel().register(eventLoop().unwrappedSelector(), 0, this); ​ 回头查看java nio channel注册的方式： 1234/*** 把一个ServerSocketChannel注册到一个Selector*/ssc.register(selector, SelectionKey.OP_ACCEPT); ​ 此时完成把channel注册到selector中 。 ​ 再来看一个序列图： ​ 可以看到在AbstractChannel的register0开启一个线程进行注册操作。 在循环中有Selector进行select操作，进行事件监听java nio 进行selector进行select等待​ 此处仅仅是对java nio channel进行初步了解，不做细节的分析，后继会进行细节分析。 123456789101112131415161718192021222324252627while (!Thread.currentThread().isInterrupted()) &#123; System.err.println("selector"); // select()阻塞，等待有事件发生唤醒 // 等待处理新的事件; // 一直阻塞直到下一个事件到来才唤醒. // 此方法执行处于阻塞模式的选择操作。 // 仅在至少选择一个通道、调用此选择器的 wakeup 方法，或者当前的线程已中断（以先到者为准）后此方法才返回。 selector.select(); System.err.println("selector…………"); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (!key.isValid()) &#123; System.err.println("check……"); continue; &#125; if (key.isAcceptable()) &#123; accept(key); &#125; else if (key.isReadable()) &#123; read(key); &#125; else if (key.isWritable()) &#123; write(key); &#125; keyIterator.remove(); //该事件已经处理，可以丢弃 &#125;&#125; Netty是如何进行select的呢？​ 先回顾channel是如何进行注册，在SingleThreadEventLoop执行了一个executor方法，是的，现在回头再看executor()会亲切一点，同时回答之前一个问题，SingleThreadEventLoop#register()方法中的线程什么时候start()呢？ 12345678910111213141516171819202122232425/*** @param task 这是一个注册channel到register的线程*/@Overridepublic void execute(Runnable task) &#123; if (task == null) &#123; throw new NullPointerException("task"); &#125; // 判断是不是一个event loop线程，即reactor中的acceptor线程 // 初始化时并不是一个eventloop的线程 boolean inEventLoop = inEventLoop(); if (inEventLoop) &#123; addTask(task); &#125; else &#123; startThread(); addTask(task); if (isShutdown() &amp;&amp; removeTask(task)) &#123; reject(); &#125; &#125; if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123; wakeup(inEventLoop); &#125;&#125; 先看SingleThreadEventLoop#startThread(); 1SingleThreadEventExecutor.this.run(); 这是一个最重要的段代码，即开始启动run这个方法，在SingleThreadEventExecutor中的run是一个抽象方法，查看具体的实现类：NioEventLoop#run，查看这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Overrideprotected void run() &#123; for (;;) &#123; try &#123; switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123; case SelectStrategy.CONTINUE: continue; case SelectStrategy.SELECT: select(wakenUp.getAndSet(false)); // 'wakenUp.compareAndSet(false, true)' is always evaluated // before calling 'selector.wakeup()' to reduce the wake-up // overhead. (Selector.wakeup() is an expensive operation.) // // However, there is a race condition in this approach. // The race condition is triggered when 'wakenUp' is set to // true too early. // // 'wakenUp' is set to true too early if: // 1) Selector is waken up between 'wakenUp.set(false)' and // 'selector.select(...)'. (BAD) // 2) Selector is waken up between 'selector.select(...)' and // 'if (wakenUp.get()) &#123; ... &#125;'. (OK) // // In the first case, 'wakenUp' is set to true and the // following 'selector.select(...)' will wake up immediately. // Until 'wakenUp' is set to false again in the next round, // 'wakenUp.compareAndSet(false, true)' will fail, and therefore // any attempt to wake up the Selector will fail, too, causing // the following 'selector.select(...)' call to block // unnecessarily. // // To fix this problem, we wake up the selector again if wakenUp // is true immediately after selector.select(...). // It is inefficient in that it wakes up the selector for both // the first case (BAD - wake-up required) and the second case // (OK - no wake-up required). if (wakenUp.get()) &#123; selector.wakeup(); &#125; // fall through default: &#125; cancelledKeys = 0; needsToSelectAgain = false; final int ioRatio = this.ioRatio; if (ioRatio == 100) &#123; try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. runAllTasks(); &#125; &#125; else &#123; final long ioStartTime = System.nanoTime(); try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. final long ioTime = System.nanoTime() - ioStartTime; // 执行任务，这个任务包含executor启动绑定selector的任务 runAllTasks(ioTime * (100 - ioRatio) / ioRatio); &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; // Always handle shutdown even if the loop processing threw an exception. try &#123; if (isShuttingDown()) &#123; closeAll(); if (confirmShutdown()) &#123; return; &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; &#125;&#125; NioEventLoop#run是一个死循环，在run方法中调用select方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private void select(boolean oldWakenUp) throws IOException &#123; Selector selector = this.selector; try &#123; int selectCnt = 0; long currentTimeNanos = System.nanoTime(); long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); for (;;) &#123; long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L; if (timeoutMillis &lt;= 0) &#123; if (selectCnt == 0) &#123; selector.selectNow(); selectCnt = 1; &#125; break; &#125; // If a task was submitted when wakenUp value was true, the task didn't get a chance to call // Selector#wakeup. So we need to check task queue again before executing select operation. // If we don't, the task might be pended until select operation was timed out. // It might be pended until idle timeout if IdleStateHandler existed in pipeline. if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123; selector.selectNow(); selectCnt = 1; break; &#125; int selectedKeys = selector.select(timeoutMillis); selectCnt ++; if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123; // - Selected something, // - waken up by user, or // - the task queue has a pending task. // - a scheduled task is ready for processing break; &#125; if (Thread.interrupted()) &#123; // Thread was interrupted so reset selected keys and break so we not run into a busy loop. // As this is most likely a bug in the handler of the user or it's client library we will // also log it. // // See https://github.com/netty/netty/issues/2426 if (logger.isDebugEnabled()) &#123; logger.debug("Selector.select() returned prematurely because " + "Thread.currentThread().interrupt() was called. Use " + "NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."); &#125; selectCnt = 1; break; &#125; long time = System.nanoTime(); if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123; // timeoutMillis elapsed without anything selected. selectCnt = 1; &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123; // The selector returned prematurely many times in a row. // Rebuild the selector to work around the problem. logger.warn( "Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.", selectCnt, selector); rebuildSelector(); selector = this.selector; // Select again to populate selectedKeys. selector.selectNow(); selectCnt = 1; break; &#125; currentTimeNanos = time; &#125; if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.", selectCnt - 1, selector); &#125; &#125; &#125; catch (CancelledKeyException e) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector &#123;&#125; - JDK bug?", selector, e); &#125; // Harmless exception - log anyway &#125;&#125; select方法是Netty对select的封装。此时完成了select的等待操作。 下面就看task什么时候执行： ​ 在executor方法中调用addTask(task);这是一个Queue，通过Queue进行执行任务，这是一个简单的生产者与消费者，由executor进行生产任务，由runAllTasks进行消费任务，在run中启动任务。 ​ 此时完成了启动绑定的操作。 ​ 在这一节出现一个重要的类，这个类就是SingleThreadEventExecutor，这个类中有一个Queue，这是一个生产者消费者的容器，用于存储每一个任务，Netty中的任务都是存储在这个Queue中，即一个EventLoop可以执行多个任务。]]></content>
      <categories>
        <category>Java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
</search>
