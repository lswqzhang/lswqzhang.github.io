<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张韶伟的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lswqzhang.github.io/"/>
  <updated>2018-01-01T14:09:24.685Z</updated>
  <id>https://lswqzhang.github.io/</id>
  
  <author>
    <name>张韶伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty</title>
    <link href="https://lswqzhang.github.io/2017/12/31/netty/"/>
    <id>https://lswqzhang.github.io/2017/12/31/netty/</id>
    <published>2017-12-31T00:28:17.000Z</published>
    <updated>2018-01-01T14:09:24.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty学习"><a href="#Netty学习" class="headerlink" title="Netty学习"></a>Netty学习</h1><h2 id="netty启动与JavaNio启动比对"><a href="#netty启动与JavaNio启动比对" class="headerlink" title="netty启动与JavaNio启动比对"></a>netty启动与JavaNio启动比对</h2><p>​    这是一个netty启动和JavaNio启动一个Socket服务的简单对比，不包含详细的分析，提供自己对Netty的简单的分析。</p><h3 id="开启一个服务套接字ServerSocketChannel"><a href="#开启一个服务套接字ServerSocketChannel" class="headerlink" title="开启一个服务套接字ServerSocketChannel"></a>开启一个服务套接字ServerSocketChannel</h3><p>在Netty中主要使用的类：NioServerSocketChannel</p><h4 id="JavaNio开启一个服务套接字通道SocketChannel"><a href="#JavaNio开启一个服务套接字通道SocketChannel" class="headerlink" title="JavaNio开启一个服务套接字通道SocketChannel"></a>JavaNio开启一个服务套接字通道SocketChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure><p>​    ServerSocketChannel.open()的内部实现使用的是SelectorProvider.provider()的方法进行实现一个SelectorProvicer的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel channel = SelectorProvider.provider().openServerSocketChannel()</span><br></pre></td></tr></table></figure><h4 id="Netty开启一个服务套接字通道的方式"><a href="#Netty开启一个服务套接字通道的方式" class="headerlink" title="Netty开启一个服务套接字通道的方式"></a>Netty开启一个服务套接字通道的方式</h4><p>​    在NioServerSocketChannel中组合一个SelectorProvider，直接SelectorProvider.provider();进行初始化</p><p>NioServerSocketChannel提供一个默认的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioServerSocketChannel实现了一个默认的SelectorProvider，这是一个单例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  Use the &#123;<span class="doctag">@link</span> SelectorProvider&#125; to open &#123;<span class="doctag">@link</span> SocketChannel&#125; and so remove condition in</span></span><br><span class="line"><span class="comment">        *  &#123;<span class="doctag">@link</span> SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *  See &lt;a href="https://github.com/netty/netty/issues/2308"&gt;#2308&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                    <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当看到openServerSocketChannel()方法的时候发现Netty也是通过java nio提供的SelectorProvicer提供单例方式实现一个服务套接字的</p><h3 id="开启一个服务套接字Selector"><a href="#开启一个服务套接字Selector" class="headerlink" title="开启一个服务套接字Selector"></a>开启一个服务套接字Selector</h3><h4 id="JavaNio开启一个服务套接字通道Selector"><a href="#JavaNio开启一个服务套接字通道Selector" class="headerlink" title="JavaNio开启一个服务套接字通道Selector"></a>JavaNio开启一个服务套接字通道Selector</h4><p>java nio通过开启一个selector进行多路复用选择器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector = Selector.open();</span><br></pre></td></tr></table></figure><p>查询Selector源码发现也是一个Selector.Provider()开启一个Selector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Opens a selector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new selector is created by invoking the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.channels.spi.SelectorProvider#openSelector openSelector&#125; method</span></span><br><span class="line"><span class="comment"> * of the system-wide default &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.channels.spi.SelectorProvider&#125; object.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  A new selector</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IOException</span></span><br><span class="line"><span class="comment"> *          If an I/O error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Netty开启一个服务套接字通道的方式-1"><a href="#Netty开启一个服务套接字通道的方式-1" class="headerlink" title="Netty开启一个服务套接字通道的方式"></a>Netty开启一个服务套接字通道的方式</h4><p>​    主要使用的类：NioEventLoopGroup、MultithreadEventLoopGroup、MultithreadEventExecutorGroup、NioEventLoop，NioEventLoop$SelectorTuple，NioEventLoop#openSelector</p><p>在openSelector方法中开启一个新的Selector，其中provider是一个Selector.Provider();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwrappedSelector = provider.openSelector()</span><br></pre></td></tr></table></figure><p>在NioEventLoop中组合了一个private final SelectorProvider provider;</p><p>NioEventLoop构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, </span><br><span class="line">             Executor executor, </span><br><span class="line">             SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, </span><br><span class="line">             RejectedExecutionHandler rejectedExecutionHandler)</span><br></pre></td></tr></table></figure><p>在这个构造方法调用了一个openSelector方法，查看一个这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        unwrappedSelector = provider.openSelector();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to open a new selector"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DISABLE_KEYSET_OPTIMIZATION) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"></span><br><span class="line">    Object maybeSelectorImplClass = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Class.forName(</span><br><span class="line">                        <span class="string">"sun.nio.ch.SelectorImpl"</span>,</span><br><span class="line">                        <span class="keyword">false</span>,</span><br><span class="line">                        PlatformDependent.getSystemClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                <span class="keyword">return</span> cause;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(maybeSelectorImplClass <span class="keyword">instanceof</span> Class) ||</span><br><span class="line">            <span class="comment">// ensure the current selector implementation is what we can instrument.</span></span><br><span class="line">            !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maybeSelectorImplClass <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">            Throwable t = (Throwable) maybeSelectorImplClass;</span><br><span class="line">            logger.trace(<span class="string">"failed to instrument a special java.util.Set into: &#123;&#125;"</span>, unwrappedSelector, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass;</span><br><span class="line"></span><br><span class="line">    Object maybeException = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"selectedKeys"</span>);</span><br><span class="line">                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"publicSelectedKeys"</span>);</span><br><span class="line"></span><br><span class="line">                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField);</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line">                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField);</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maybeException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">        selectedKeys = <span class="keyword">null</span>;</span><br><span class="line">        Exception e = (Exception) maybeException;</span><br><span class="line">        logger.trace(<span class="string">"failed to instrument a special java.util.Set into: &#123;&#125;"</span>, unwrappedSelector, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">    &#125;</span><br><span class="line">    selectedKeys = selectedKeySet;</span><br><span class="line">    logger.trace(<span class="string">"instrumented a special java.util.Set into: &#123;&#125;"</span>, unwrappedSelector);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector,</span><br><span class="line">                             <span class="keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个方法中有一段代码：unwrappedSelector = provider.openSelector();这个就是在java nio中使用这provider的openSelector();</p><p>​    如何使用NioEventLoop类的呢，这需要了解reactor模型，这是一个基础概念的问题，在这里不进行说明，后继会加入对reactor描述，这里仅仅知道就可以了。</p><p>​    在实现一个ServerSocket的时候会初始化一个NioEventLoopGroup，可以是两个，一个作为reactor中的accept，一个作为io的read或者write</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程模型,accetp作为main reactor</span></span><br><span class="line"><span class="comment">// main reactor是一个单线程</span></span><br><span class="line"><span class="keyword">int</span> nThreads = <span class="number">1</span>;</span><br><span class="line">EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup(nThreads);</span><br><span class="line"><span class="comment">// sub reactor中一个多线程</span></span><br><span class="line">EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>看一个EventLoopGroup的类图，只画出关键的类图</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fn11hi036jj31kw0ogq6g.jpg" alt="netty初始化一个selector"></p><p>​    在MultithreadEventExecutorGroup构造方法中调用newChild方法，实例化一个NioEventLoop并存放于children中</p><p>查看MultithreadEventExecutorGroup的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads          the number of threads that will be used by this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor          the Executor to use, or &#123;<span class="doctag">@code</span> null&#125; if the default should be used.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chooserFactory    the &#123;<span class="doctag">@link</span> EventExecutorChooserFactory&#125; to use.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args              arguments which will passed to each &#123;<span class="doctag">@link</span> #newChild(Executor, Object...)&#125; call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当然这个构造方法中有很多的其它操作，但是在看源码中先关注脉络，再看细节，不要掉一个小的细节中出不来，就没有办法再看下去了；因此这段代码中我们只需要关注children[i] = newChild(executor, args);这个方法即可。</p><p>​    这个方法在类图中有newChild展示方法，这个方法最终实现类是NioEventLoopGroup，这里具体查看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    是的，这个方法有没有比较熟悉，对，这个就是开头讲的那个构造方法，到此时为止，完全明白了netty是如何开启一个selector的了，代码内部和java nio开启selector并没有太大的差别。</p><p>​    到目前为止了解了netty是如何开启一个NioServerSocketChannel的与启用一个Selector的。</p><h3 id="将channel注册到selector中"><a href="#将channel注册到selector中" class="headerlink" title="将channel注册到selector中"></a>将channel注册到selector中</h3><h4 id="JavaNio将一个ServerSocketChannel注册到Selector中"><a href="#JavaNio将一个ServerSocketChannel注册到Selector中" class="headerlink" title="JavaNio将一个ServerSocketChannel注册到Selector中"></a>JavaNio将一个ServerSocketChannel注册到Selector中</h4><p>​    将一个ServerSocketChannel注册到一个Selector，由于两个Open内部都使用了SelectorProvider.provider();这个方法是单例的，因此使用的是一个SelectorProvider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是第一步开启的一个ServerSocketChannel</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是第二步打开一个Selector</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把一个ServerSocketChannel注册到一个Selector</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><h3 id="Netty是如何注册一个ServerSocketChannel的呢？"><a href="#Netty是如何注册一个ServerSocketChannel的呢？" class="headerlink" title="Netty是如何注册一个ServerSocketChannel的呢？"></a>Netty是如何注册一个ServerSocketChannel的呢？</h3><p>​    需要查看实现一个ServerSocket需要的步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure the server.</span></span><br><span class="line"><span class="comment">// 多线程模型</span></span><br><span class="line"><span class="keyword">int</span> nThreads = <span class="number">1</span>;</span><br><span class="line">EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup(nThreads);</span><br><span class="line">EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    b.group(parentGroup, childGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">            .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">            .childHandler(<span class="keyword">new</span> EchoServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the server.</span></span><br><span class="line">    ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">    parentGroup.shutdownGracefully();</span><br><span class="line">    childGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这就是实现一个ServerSocket的方法，查看bind方法：AbstractBootstrap—&gt;ServerBootstrap，bind为AbstractBootstrap中的一个方法，最终调用的是initAndRegister()方法，需要详细的看一下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="comment">// ReflectiveChannelFactory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ChannelFactory&lt;? extends C&gt; channelFactory;</span><br><span class="line">在initAndRegister方法实例化了一个channel，这个channel中NioServerSocketChannel的实例</span><br><span class="line">channel = channelFactory.newChannel();</span><br></pre></td></tr></table></figure><p>​    查看完整的initAndRegister方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 成员变量实例化一个NioServerSocketChannel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// group为NioEventLoopGroup，即为MultithreadEventLoopGroup</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are here and the promise is not failed, it's one of the following cases:</span></span><br><span class="line">    <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></span><br><span class="line">    <span class="comment">//    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.</span></span><br><span class="line">    <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></span><br><span class="line">    <span class="comment">//    added to the event loop's task queue for later execution.</span></span><br><span class="line">    <span class="comment">//    i.e. It's safe to attempt bind() or connect() now:</span></span><br><span class="line">    <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></span><br><span class="line">    <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    调用register方法，最终调用的是AbstractChannel的register进行channel注册到EventLoop当中。</p><p>​    AbstractChannel中包含一个EventLoop，即一个channel只属于一个EventLoop，即把channel分配给相应的EventLoop（同时一个EventLoop只能交由一个Thread进行处理，当然这个后继会说明）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netty学习&quot;&gt;&lt;a href=&quot;#Netty学习&quot; class=&quot;headerlink&quot; title=&quot;Netty学习&quot;&gt;&lt;/a&gt;Netty学习&lt;/h1&gt;&lt;h2 id=&quot;netty启动与JavaNio启动比对&quot;&gt;&lt;a href=&quot;#netty启动与JavaNi
      
    
    </summary>
    
      <category term="Java" scheme="https://lswqzhang.github.io/categories/Java/"/>
    
      <category term="Netty" scheme="https://lswqzhang.github.io/categories/Java/Netty/"/>
    
    
      <category term="Java" scheme="https://lswqzhang.github.io/tags/Java/"/>
    
      <category term="Netty" scheme="https://lswqzhang.github.io/tags/Netty/"/>
    
  </entry>
  
</feed>
